
NRFBootLoaderViaMicrochip.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  00000991  2**0
                  ALLOC, LOAD, DATA
  1 .text         00000350  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .comment      0000002f  00000000  00000000  00000991  2**0
                  CONTENTS, READONLY
  3 .version      00000002  00000000  00000000  000009c0  2**0
                  CONTENTS, READONLY
  4 .stack.descriptors.hdr 0000000e  00000000  00000000  000009c2  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 00000128  00000000  00000000  000009d0  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001c86  00000000  00000000  00000af8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000086d  00000000  00000000  0000277e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000c95  00000000  00000000  00002feb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000280  00000000  00000000  00003c80  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000227  00000000  00000000  00003f00  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000b4a  00000000  00000000  00004127  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000110  00000000  00000000  00004c71  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .text         00000004  000008d8  000008d8  0000098c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 14 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004d84  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .text.eeprom_write 00000018  000007e4  000007e4  00000898  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 16 .text.eeprom_read 00000012  00000868  00000868  0000091c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 17 .text.spi_mode 00000012  0000087a  0000087a  0000092e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 18 .text.spi_init 0000001a  000007b0  000007b0  00000864  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 19 .text.spi_transfer 00000018  000007fc  000007fc  000008b0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 20 .text.delay8  00000020  00000738  00000738  000007ec  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 21 .text.nrf24_read_reg 00000018  00000814  00000814  000008c8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 22 .text.nrf24_write_reg 00000020  00000758  00000758  0000080c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 23 .text.nrf24_read_status 00000014  0000082c  0000082c  000008e0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 24 .text.nrf24_write_addr_reg 00000030  000006dc  000006dc  00000790  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 25 .text.nrf24_tx_flush 00000014  00000840  00000840  000008f4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 26 .text.nrf24_delay 0000000a  000008c4  000008c4  00000978  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 27 .text.nrf24_init 0000007a  000004f0  000004f0  000005a4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 28 .text.nrf24_set_rx_addr 0000000a  000008ce  000008ce  00000982  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 29 .text.nrf24_set_tx_addr 0000001c  00000778  00000778  0000082c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 30 .text.nrf24_rx_mode 0000002c  0000070c  0000070c  000007c0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 31 .text.nrf24_idle_mode 00000046  00000696  00000696  0000074a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 32 .text.nrf24_rx_fifo_data 0000000e  0000089c  0000089c  00000950  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 33 .text.nrf24_rx_data_avail 0000001a  000007ca  000007ca  0000087e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 34 .text.nrf24_rx_read 00000062  000005e0  000005e0  00000694  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 35 .text.nrf24_tx 00000084  000003f0  000003f0  000004a4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 36 .text.nrf24_tx_result_wait 00000076  0000056a  0000056a  0000061e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 37 .text.radio_init 0000007c  00000474  00000474  00000528  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 38 .text.putch   00000054  00000642  00000642  000006f6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 39 .text.getch   000000a0  00000350  00000350  00000404  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 40 .text.watchdogConfig 0000000c  000008b8  000008b8  0000096c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 41 .text.wait_timeout 0000000e  000008aa  000008aa  0000095e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 42 .text.verifySpace 00000014  00000854  00000854  00000908  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 43 .text.appStart 00000010  0000088c  0000088c  00000940  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 44 .bss.pkt_start.1991 00000001  00800140  00800140  00000991  2**0
                  ALLOC
 45 .bss.pkt_buf.1992 00000020  00800100  00800100  00000991  2**0
                  ALLOC
 46 .bss.pkt_len.1990 00000001  00800141  00800141  00000991  2**0
                  ALLOC
 47 .bss.pkt_buf.1982 00000020  00800120  00800120  00000991  2**0
                  ALLOC
 48 .bss.pkt_len.1981 00000001  00800142  00800142  00000991  2**0
                  ALLOC
 49 .bss.nrf24_in_rx 00000001  00800143  00800143  00000991  2**0
                  ALLOC
 50 .data.pkt_max_len 00000001  00800144  000008dc  00000990  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 51 .bss.radio_present 00000001  00800145  00800145  00000991  2**0
                  ALLOC
 52 .bss.radio_mode 00000001  00800146  00800146  00000991  2**0
                  ALLOC
 53 .text.avrlibc 0000001c  00000794  00000794  00000848  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 3d 00 	jmp	0x7a	; 0x7a <__ctors_end>
   4:	0c 94 6c 04 	jmp	0x8d8	; 0x8d8 <__bad_interrupt>
   8:	0c 94 6c 04 	jmp	0x8d8	; 0x8d8 <__bad_interrupt>
   c:	0c 94 6c 04 	jmp	0x8d8	; 0x8d8 <__bad_interrupt>
  10:	0c 94 6c 04 	jmp	0x8d8	; 0x8d8 <__bad_interrupt>
  14:	0c 94 6c 04 	jmp	0x8d8	; 0x8d8 <__bad_interrupt>
  18:	0c 94 6c 04 	jmp	0x8d8	; 0x8d8 <__bad_interrupt>
  1c:	0c 94 6c 04 	jmp	0x8d8	; 0x8d8 <__bad_interrupt>
  20:	0c 94 6c 04 	jmp	0x8d8	; 0x8d8 <__bad_interrupt>
  24:	0c 94 6c 04 	jmp	0x8d8	; 0x8d8 <__bad_interrupt>
  28:	0c 94 6c 04 	jmp	0x8d8	; 0x8d8 <__bad_interrupt>
  2c:	0c 94 6c 04 	jmp	0x8d8	; 0x8d8 <__bad_interrupt>
  30:	0c 94 6c 04 	jmp	0x8d8	; 0x8d8 <__bad_interrupt>
  34:	0c 94 6c 04 	jmp	0x8d8	; 0x8d8 <__bad_interrupt>
  38:	0c 94 6c 04 	jmp	0x8d8	; 0x8d8 <__bad_interrupt>
  3c:	0c 94 6c 04 	jmp	0x8d8	; 0x8d8 <__bad_interrupt>
  40:	0c 94 6c 04 	jmp	0x8d8	; 0x8d8 <__bad_interrupt>
  44:	0c 94 6c 04 	jmp	0x8d8	; 0x8d8 <__bad_interrupt>
  48:	0c 94 6c 04 	jmp	0x8d8	; 0x8d8 <__bad_interrupt>
  4c:	0c 94 6c 04 	jmp	0x8d8	; 0x8d8 <__bad_interrupt>
  50:	0c 94 6c 04 	jmp	0x8d8	; 0x8d8 <__bad_interrupt>
  54:	0c 94 6c 04 	jmp	0x8d8	; 0x8d8 <__bad_interrupt>
  58:	0c 94 6c 04 	jmp	0x8d8	; 0x8d8 <__bad_interrupt>
  5c:	0c 94 6c 04 	jmp	0x8d8	; 0x8d8 <__bad_interrupt>
  60:	0c 94 6c 04 	jmp	0x8d8	; 0x8d8 <__bad_interrupt>
  64:	0c 94 6c 04 	jmp	0x8d8	; 0x8d8 <__bad_interrupt>

00000068 <.dinit>:
  68:	01 00       	.word	0x0001	; ????
  6a:	01 44       	sbci	r16, 0x41	; 65
  6c:	80 01       	movw	r16, r0
  6e:	44 01       	movw	r8, r8
  70:	45 00       	.word	0x0045	; ????
  72:	08 dc       	rcall	.-2032   	; 0xfffff884 <__eeprom_end+0xff7ef884>
  74:	01 45       	sbci	r16, 0x51	; 81
  76:	01 47       	sbci	r16, 0x71	; 113
  78:	80 00       	.word	0x0080	; ????

0000007a <__ctors_end>:
  7a:	11 24       	eor	r1, r1
  7c:	1f be       	out	0x3f, r1	; 63
  7e:	cf ef       	ldi	r28, 0xFF	; 255
  80:	d4 e0       	ldi	r29, 0x04	; 4
  82:	de bf       	out	0x3e, r29	; 62
  84:	cd bf       	out	0x3d, r28	; 61

00000086 <__do_copy_data>:
  86:	e8 e6       	ldi	r30, 0x68	; 104
  88:	f0 e0       	ldi	r31, 0x00	; 0
  8a:	40 e0       	ldi	r20, 0x00	; 0
  8c:	17 c0       	rjmp	.+46     	; 0xbc <__do_clear_bss+0x8>
  8e:	b5 91       	lpm	r27, Z+
  90:	a5 91       	lpm	r26, Z+
  92:	35 91       	lpm	r19, Z+
  94:	25 91       	lpm	r18, Z+
  96:	05 91       	lpm	r16, Z+
  98:	07 fd       	sbrc	r16, 7
  9a:	0c c0       	rjmp	.+24     	; 0xb4 <__do_clear_bss>
  9c:	95 91       	lpm	r25, Z+
  9e:	85 91       	lpm	r24, Z+
  a0:	ef 01       	movw	r28, r30
  a2:	f9 2f       	mov	r31, r25
  a4:	e8 2f       	mov	r30, r24
  a6:	05 90       	lpm	r0, Z+
  a8:	0d 92       	st	X+, r0
  aa:	a2 17       	cp	r26, r18
  ac:	b3 07       	cpc	r27, r19
  ae:	d9 f7       	brne	.-10     	; 0xa6 <__do_copy_data+0x20>
  b0:	fe 01       	movw	r30, r28
  b2:	04 c0       	rjmp	.+8      	; 0xbc <__do_clear_bss+0x8>

000000b4 <__do_clear_bss>:
  b4:	1d 92       	st	X+, r1
  b6:	a2 17       	cp	r26, r18
  b8:	b3 07       	cpc	r27, r19
  ba:	e1 f7       	brne	.-8      	; 0xb4 <__do_clear_bss>
  bc:	e9 37       	cpi	r30, 0x79	; 121
  be:	f4 07       	cpc	r31, r20
  c0:	31 f7       	brne	.-52     	; 0x8e <__do_copy_data+0x8>
  c2:	0e 94 65 00 	call	0xca	; 0xca <main>
  c6:	0c 94 a6 01 	jmp	0x34c	; 0x34c <_exit>

000000ca <main>:
  //  SP points to RAMEND
  //  r1 contains zero
  //
  // If not, uncomment the following instructions:
  // cli();
  asm volatile ("cli");
  ca:	f8 94       	cli
  asm volatile ("clr __zero_reg__");
  cc:	11 24       	eor	r1, r1
  /* Save the original reset reason to pass on to the applicatoin */
  reset_cause = ch;
  marker = 0xdeadbeef;
#else
  // Adaboot no-wait mod
  ch = MCUSR;
  ce:	84 b7       	in	r24, 0x34	; 52
  MCUSR = 0;
  d0:	14 be       	out	0x34, r1	; 52
  if (ch & (_BV(WDRF) | _BV(PORF) | _BV(BORF)))
  d2:	98 2f       	mov	r25, r24
  d4:	9d 70       	andi	r25, 0x0D	; 13
  d6:	11 f0       	breq	.+4      	; 0xdc <main+0x12>
    appStart(ch);
  d8:	0e 94 46 04 	call	0x88c	; 0x88c <appStart>
#endif

#if BSS_SIZE > 0
  // Prepare .data
  asm volatile (
  dc:	11 e0       	ldi	r17, 0x01	; 1
  de:	a0 e0       	ldi	r26, 0x00	; 0
  e0:	b1 e0       	ldi	r27, 0x01	; 1
  e2:	e0 e5       	ldi	r30, 0x50	; 80
  e4:	f3 e0       	ldi	r31, 0x03	; 3
  e6:	02 c0       	rjmp	.+4      	; 0xec <cpchk>

000000e8 <copy>:
  e8:	05 90       	lpm	r0, Z+
  ea:	0d 92       	st	X+, r0

000000ec <cpchk>:
  ec:	a0 30       	cpi	r26, 0x00	; 0
  ee:	b1 07       	cpc	r27, r17
  f0:	d9 f7       	brne	.-10     	; 0xe8 <copy>
	"	st	X+, __tmp_reg__\n"
	"cpchk:	cpi	r26, lo8(__data_end)\n"
	"	cpc	r27, r17\n"
	"	brne	copy\n");
  // Prepare .bss
  asm volatile (
  f2:	11 e0       	ldi	r17, 0x01	; 1
  f4:	a0 e0       	ldi	r26, 0x00	; 0
  f6:	b1 e0       	ldi	r27, 0x01	; 1
  f8:	01 c0       	rjmp	.+2      	; 0xfc <clchk>

000000fa <clear>:
  fa:	1d 92       	st	X+, r1

000000fc <clchk>:
  fc:	a0 30       	cpi	r26, 0x00	; 0
  fe:	b1 07       	cpc	r27, r17
 100:	e1 f7       	brne	.-8      	; 0xfa <clear>
  /*
   * Disable pullups that may have been enabled by a user program.
   * Somehow a pullup on RXD screws up everything unless RXD is externally
   * driven high.
   */
  DDRD |= 3;
 102:	8a b1       	in	r24, 0x0a	; 10
 104:	83 60       	ori	r24, 0x03	; 3
 106:	8a b9       	out	0x0a, r24	; 10
  PORTD &= ~3;
 108:	8b b1       	in	r24, 0x0b	; 11
 10a:	8c 7f       	andi	r24, 0xFC	; 252
 10c:	8b b9       	out	0x0b, r24	; 11
  UCSRA = _BV(U2X); //Double speed mode USART
  UCSRB = _BV(RXEN) | _BV(TXEN);  // enable Rx & Tx
  UCSRC = _BV(URSEL) | _BV(UCSZ1) | _BV(UCSZ0);  // config USART; 8N1
  UBRRL = (uint8_t)( (F_CPU + BAUD_RATE * 4L) / (BAUD_RATE * 8L) - 1 );
#else
  UART_SRA = _BV(U2X0); //Double speed mode USART0
 10e:	82 e0       	ldi	r24, 0x02	; 2
 110:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fc0c0>
  UART_SRB = _BV(RXEN0) | _BV(TXEN0);
 114:	88 e1       	ldi	r24, 0x18	; 24
 116:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7fc0c1>
  UART_SRC = _BV(UCSZ00) | _BV(UCSZ01);
 11a:	86 e0       	ldi	r24, 0x06	; 6
 11c:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7fc0c2>
  UART_SRL = (uint8_t)( (F_CPU + BAUD_RATE * 4L) / (BAUD_RATE * 8L) - 1 );
 120:	88 e0       	ldi	r24, 0x08	; 8
 122:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7fc0c4>
#endif
#endif
#ifdef RADIO_UART
  radio_init();
 126:	0e 94 3a 02 	call	0x474	; 0x474 <radio_init>
#endif

  // Set up watchdog to trigger after 500ms
  watchdogConfig(WATCHDOG_1S);
 12a:	8e e0       	ldi	r24, 0x0E	; 14
 12c:	0e 94 5c 04 	call	0x8b8	; 0x8b8 <watchdogConfig>
   * Making these local and in registers prevents the need for initializing
   * them, and also saves space because code no longer stores to memory.
   * (initializing address keeps the compiler happy, but isn't really
   *  necessary, and uses 4 bytes of flash.)
   */
  register uint16_t address = 0;
 130:	00 e0       	ldi	r16, 0x00	; 0
 132:	10 e0       	ldi	r17, 0x00	; 0
#endif

  /* Forever loop */
  for (;;) {
    /* get character from UART */
    ch = getch();
 134:	0e 94 a8 01 	call	0x350	; 0x350 <_etext>

    if(ch == STK_GET_PARAMETER) {
 138:	81 34       	cpi	r24, 0x41	; 65
 13a:	a9 f4       	brne	.+42     	; 0x166 <clchk+0x6a>
      unsigned char which = getch();
 13c:	0e 94 a8 01 	call	0x350	; 0x350 <_etext>
 140:	c8 2f       	mov	r28, r24
      verifySpace();
 142:	0e 94 2a 04 	call	0x854	; 0x854 <verifySpace>
      if (which == 0x82) {
 146:	c2 38       	cpi	r28, 0x82	; 130
 148:	21 f4       	brne	.+8      	; 0x152 <clchk+0x56>
	/*
	 * Send optiboot version as "minor SW version"
	 */
	putch(OPTIBOOT_MINVER);
 14a:	80 e0       	ldi	r24, 0x00	; 0
 14c:	0e 94 21 03 	call	0x642	; 0x642 <putch>
 150:	f9 c0       	rjmp	.+498    	; 0x344 <__EEPROM_REGION_LENGTH__+0x144>
      } else if (which == 0x81) {
 152:	c1 38       	cpi	r28, 0x81	; 129
 154:	21 f4       	brne	.+8      	; 0x15e <clchk+0x62>
	  putch(OPTIBOOT_MAJVER);
 156:	85 e0       	ldi	r24, 0x05	; 5
 158:	0e 94 21 03 	call	0x642	; 0x642 <putch>
 15c:	f3 c0       	rjmp	.+486    	; 0x344 <__EEPROM_REGION_LENGTH__+0x144>
      } else {
	/*
	 * GET PARAMETER returns a generic 0x03 reply for
         * other parameters - enough to keep Avrdude happy
	 */
	putch(0x03);
 15e:	83 e0       	ldi	r24, 0x03	; 3
 160:	0e 94 21 03 	call	0x642	; 0x642 <putch>
 164:	ef c0       	rjmp	.+478    	; 0x344 <__EEPROM_REGION_LENGTH__+0x144>
      }
    }
    else if(ch == STK_SET_DEVICE) {
 166:	82 34       	cpi	r24, 0x42	; 66
 168:	41 f4       	brne	.+16     	; 0x17a <clchk+0x7e>
 16a:	c4 e1       	ldi	r28, 0x14	; 20
  );
}
#endif

void getNch(uint8_t count) {
  do getch(); while (--count);
 16c:	0e 94 a8 01 	call	0x350	; 0x350 <_etext>
 170:	c1 50       	subi	r28, 0x01	; 1
 172:	e1 f7       	brne	.-8      	; 0x16c <clchk+0x70>
  verifySpace();
 174:	0e 94 2a 04 	call	0x854	; 0x854 <verifySpace>
 178:	e5 c0       	rjmp	.+458    	; 0x344 <__EEPROM_REGION_LENGTH__+0x144>
    }
    else if(ch == STK_SET_DEVICE) {
      // SET DEVICE is ignored
      getNch(20);
    }
    else if(ch == STK_SET_DEVICE_EXT) {
 17a:	85 34       	cpi	r24, 0x45	; 69
 17c:	41 f4       	brne	.+16     	; 0x18e <clchk+0x92>
 17e:	c5 e0       	ldi	r28, 0x05	; 5
  );
}
#endif

void getNch(uint8_t count) {
  do getch(); while (--count);
 180:	0e 94 a8 01 	call	0x350	; 0x350 <_etext>
 184:	c1 50       	subi	r28, 0x01	; 1
 186:	e1 f7       	brne	.-8      	; 0x180 <clchk+0x84>
  verifySpace();
 188:	0e 94 2a 04 	call	0x854	; 0x854 <verifySpace>
 18c:	db c0       	rjmp	.+438    	; 0x344 <__EEPROM_REGION_LENGTH__+0x144>
    }
    else if(ch == STK_SET_DEVICE_EXT) {
      // SET DEVICE EXT is ignored
      getNch(5);
    }
    else if(ch == STK_LOAD_ADDRESS) {
 18e:	85 35       	cpi	r24, 0x55	; 85
 190:	89 f4       	brne	.+34     	; 0x1b4 <clchk+0xb8>
      // LOAD ADDRESS
      uint16_t newAddress;
      newAddress = getch();
 192:	0e 94 a8 01 	call	0x350	; 0x350 <_etext>
 196:	c8 2f       	mov	r28, r24
 198:	d0 e0       	ldi	r29, 0x00	; 0
      newAddress |= getch() << 8;
 19a:	0e 94 a8 01 	call	0x350	; 0x350 <_etext>
 19e:	08 2f       	mov	r16, r24
 1a0:	10 e0       	ldi	r17, 0x00	; 0
 1a2:	10 2f       	mov	r17, r16
 1a4:	00 27       	eor	r16, r16
 1a6:	0c 2b       	or	r16, r28
 1a8:	1d 2b       	or	r17, r29
#ifdef RAMPZ
      // Transfer top bit to RAMPZ
      RAMPZ = (newAddress & 0x8000) ? 1 : 0;
#endif
      newAddress <<= 1; // Convert from word address to byte address
 1aa:	00 0f       	add	r16, r16
 1ac:	11 1f       	adc	r17, r17
      address = newAddress;
      verifySpace();
 1ae:	0e 94 2a 04 	call	0x854	; 0x854 <verifySpace>
 1b2:	c8 c0       	rjmp	.+400    	; 0x344 <__EEPROM_REGION_LENGTH__+0x144>
    }
    else if(ch == STK_UNIVERSAL) {
 1b4:	86 35       	cpi	r24, 0x56	; 86
 1b6:	59 f4       	brne	.+22     	; 0x1ce <clchk+0xd2>
 1b8:	c4 e0       	ldi	r28, 0x04	; 4
  );
}
#endif

void getNch(uint8_t count) {
  do getch(); while (--count);
 1ba:	0e 94 a8 01 	call	0x350	; 0x350 <_etext>
 1be:	c1 50       	subi	r28, 0x01	; 1
 1c0:	e1 f7       	brne	.-8      	; 0x1ba <clchk+0xbe>
  verifySpace();
 1c2:	0e 94 2a 04 	call	0x854	; 0x854 <verifySpace>
      verifySpace();
    }
    else if(ch == STK_UNIVERSAL) {
      // UNIVERSAL command is ignored
      getNch(4);
      putch(0x00);
 1c6:	80 e0       	ldi	r24, 0x00	; 0
 1c8:	0e 94 21 03 	call	0x642	; 0x642 <putch>
 1cc:	bb c0       	rjmp	.+374    	; 0x344 <__EEPROM_REGION_LENGTH__+0x144>
    }
    /* Write memory, length is big endian and is in bytes */
    else if(ch == STK_PROG_PAGE) {
 1ce:	84 36       	cpi	r24, 0x64	; 100
 1d0:	09 f0       	breq	.+2      	; 0x1d4 <clchk+0xd8>
 1d2:	77 c0       	rjmp	.+238    	; 0x2c2 <__EEPROM_REGION_LENGTH__+0xc2>
      // PROGRAM PAGE - we support flash and EEPROM programming
      uint8_t *bufPtr;
      uint16_t addrPtr;
      uint8_t type;

      getch();			/* getlen() */
 1d4:	0e 94 a8 01 	call	0x350	; 0x350 <_etext>
      length = getch();
 1d8:	0e 94 a8 01 	call	0x350	; 0x350 <_etext>
 1dc:	f8 2e       	mov	r15, r24
      type = getch();
 1de:	0e 94 a8 01 	call	0x350	; 0x350 <_etext>
 1e2:	e8 2e       	mov	r14, r24

#ifdef SUPPORT_EEPROM
      if (type == 'F')		/* Flash */
 1e4:	86 e4       	ldi	r24, 0x46	; 70
 1e6:	e8 12       	cpse	r14, r24
 1e8:	0b c0       	rjmp	.+22     	; 0x200 <__EEPROM_REGION_LENGTH__>
#endif
        // If we are in RWW section, immediately start page erase
        if (address < NRWWSTART) __boot_page_erase_short((uint16_t)(void*)address);
 1ea:	01 15       	cp	r16, r1
 1ec:	e8 e3       	ldi	r30, 0x38	; 56
 1ee:	1e 07       	cpc	r17, r30
 1f0:	50 f4       	brcc	.+20     	; 0x206 <__EEPROM_REGION_LENGTH__+0x6>
 1f2:	83 e0       	ldi	r24, 0x03	; 3
 1f4:	f8 01       	movw	r30, r16
 1f6:	87 bf       	out	0x37, r24	; 55
 1f8:	e8 95       	spm
 1fa:	c0 e8       	ldi	r28, 0x80	; 128
 1fc:	d1 e0       	ldi	r29, 0x01	; 1
 1fe:	05 c0       	rjmp	.+10     	; 0x20a <__EEPROM_REGION_LENGTH__+0xa>
 200:	c0 e8       	ldi	r28, 0x80	; 128
 202:	d1 e0       	ldi	r29, 0x01	; 1
 204:	02 c0       	rjmp	.+4      	; 0x20a <__EEPROM_REGION_LENGTH__+0xa>
 206:	c0 e8       	ldi	r28, 0x80	; 128
 208:	d1 e0       	ldi	r29, 0x01	; 1

      // While that is going on, read in page contents
      bufPtr = buff;
      do *bufPtr++ = getch();
 20a:	6e 01       	movw	r12, r28
 20c:	ff ef       	ldi	r31, 0xFF	; 255
 20e:	cf 1a       	sub	r12, r31
 210:	df 0a       	sbc	r13, r31
 212:	0e 94 a8 01 	call	0x350	; 0x350 <_etext>
 216:	88 83       	st	Y, r24
      while (--length);
 218:	fa 94       	dec	r15
        // If we are in RWW section, immediately start page erase
        if (address < NRWWSTART) __boot_page_erase_short((uint16_t)(void*)address);

      // While that is going on, read in page contents
      bufPtr = buff;
      do *bufPtr++ = getch();
 21a:	e6 01       	movw	r28, r12
      while (--length);
 21c:	f1 10       	cpse	r15, r1
 21e:	f5 cf       	rjmp	.-22     	; 0x20a <__EEPROM_REGION_LENGTH__+0xa>

#ifdef SUPPORT_EEPROM
      if (type == 'F') {	/* Flash */
 220:	86 e4       	ldi	r24, 0x46	; 70
 222:	e8 12       	cpse	r14, r24
 224:	2f c0       	rjmp	.+94     	; 0x284 <__EEPROM_REGION_LENGTH__+0x84>
#endif
        // If we are in NRWW section, page erase has to be delayed until now.
        // Todo: Take RAMPZ into account (not doing so just means that we will
        //  treat the top of both "pages" of flash as NRWW, for a slight speed
        //  decrease, so fixing this is not urgent.)
        if (address >= NRWWSTART) __boot_page_erase_short((uint16_t)(void*)address);
 226:	01 15       	cp	r16, r1
 228:	e8 e3       	ldi	r30, 0x38	; 56
 22a:	1e 07       	cpc	r17, r30
 22c:	20 f0       	brcs	.+8      	; 0x236 <__EEPROM_REGION_LENGTH__+0x36>
 22e:	83 e0       	ldi	r24, 0x03	; 3
 230:	f8 01       	movw	r30, r16
 232:	87 bf       	out	0x37, r24	; 55
 234:	e8 95       	spm

        // Read command terminator, start reply
        verifySpace();
 236:	0e 94 2a 04 	call	0x854	; 0x854 <verifySpace>

        // If only a partial page is to be programmed, the erase might not be complete.
        // So check that here
        boot_spm_busy_wait();
 23a:	07 b6       	in	r0, 0x37	; 55
 23c:	00 fc       	sbrc	r0, 0
 23e:	fd cf       	rjmp	.-6      	; 0x23a <__EEPROM_REGION_LENGTH__+0x3a>
 240:	f8 01       	movw	r30, r16
 242:	a0 e8       	ldi	r26, 0x80	; 128
 244:	b1 e0       	ldi	r27, 0x01	; 1
 246:	20 e4       	ldi	r18, 0x40	; 64
        bufPtr = buff;
        addrPtr = (uint16_t)(void*)address;
        ch = SPM_PAGESIZE / 2;
        do {
          uint16_t a;
          a = *bufPtr++;
 248:	3c 91       	ld	r19, X
          a |= (*bufPtr++) << 8;
 24a:	ad 01       	movw	r20, r26
 24c:	4e 5f       	subi	r20, 0xFE	; 254
 24e:	5f 4f       	sbci	r21, 0xFF	; 255
 250:	11 96       	adiw	r26, 0x01	; 1
 252:	8c 91       	ld	r24, X
 254:	90 e0       	ldi	r25, 0x00	; 0
 256:	98 2f       	mov	r25, r24
 258:	88 27       	eor	r24, r24
 25a:	83 2b       	or	r24, r19
          __boot_page_fill_short((uint16_t)(void*)addrPtr,a);
 25c:	31 e0       	ldi	r19, 0x01	; 1
 25e:	0c 01       	movw	r0, r24
 260:	37 bf       	out	0x37, r19	; 55
 262:	e8 95       	spm
 264:	11 24       	eor	r1, r1
          addrPtr += 2;
 266:	32 96       	adiw	r30, 0x02	; 2
        } while (--ch);
 268:	21 50       	subi	r18, 0x01	; 1
        addrPtr = (uint16_t)(void*)address;
        ch = SPM_PAGESIZE / 2;
        do {
          uint16_t a;
          a = *bufPtr++;
          a |= (*bufPtr++) << 8;
 26a:	da 01       	movw	r26, r20
          __boot_page_fill_short((uint16_t)(void*)addrPtr,a);
          addrPtr += 2;
        } while (--ch);
 26c:	69 f7       	brne	.-38     	; 0x248 <__EEPROM_REGION_LENGTH__+0x48>

        // Write from programming buffer
        __boot_page_write_short((uint16_t)(void*)address);
 26e:	85 e0       	ldi	r24, 0x05	; 5
 270:	f8 01       	movw	r30, r16
 272:	87 bf       	out	0x37, r24	; 55
 274:	e8 95       	spm
        boot_spm_busy_wait();
 276:	07 b6       	in	r0, 0x37	; 55
 278:	00 fc       	sbrc	r0, 0
 27a:	fd cf       	rjmp	.-6      	; 0x276 <__EEPROM_REGION_LENGTH__+0x76>

#if defined(RWWSRE)
        // Reenable read access to flash
        boot_rww_enable();
 27c:	81 e1       	ldi	r24, 0x11	; 17
 27e:	87 bf       	out	0x37, r24	; 55
 280:	e8 95       	spm
 282:	60 c0       	rjmp	.+192    	; 0x344 <__EEPROM_REGION_LENGTH__+0x144>
#endif
#ifdef SUPPORT_EEPROM
      } else if (type == 'E') {	/* EEPROM */
 284:	f5 e4       	ldi	r31, 0x45	; 69
 286:	ef 12       	cpse	r14, r31
 288:	5d c0       	rjmp	.+186    	; 0x344 <__EEPROM_REGION_LENGTH__+0x144>
        // Read command terminator, start reply
        verifySpace();
 28a:	0e 94 2a 04 	call	0x854	; 0x854 <verifySpace>

        length = bufPtr - buff;
 28e:	90 e8       	ldi	r25, 0x80	; 128
 290:	9c 0d       	add	r25, r12
        addrPtr = address;
 292:	98 01       	movw	r18, r16
        bufPtr = buff;
 294:	e0 e8       	ldi	r30, 0x80	; 128
 296:	f1 e0       	ldi	r31, 0x01	; 1
        while (length--) {
 298:	0e c0       	rjmp	.+28     	; 0x2b6 <__EEPROM_REGION_LENGTH__+0xb6>
}
#endif

// Watchdog functions. These are only safe with interrupts turned off.
void watchdogReset() {
  __asm__ __volatile__ (
 29a:	a8 95       	wdr
        length = bufPtr - buff;
        addrPtr = address;
        bufPtr = buff;
        while (length--) {
          watchdogReset();
          eeprom_write(addrPtr++, *bufPtr++);
 29c:	ef 01       	movw	r28, r30
 29e:	21 96       	adiw	r28, 0x01	; 1
 2a0:	79 01       	movw	r14, r18
 2a2:	8f ef       	ldi	r24, 0xFF	; 255
 2a4:	e8 1a       	sub	r14, r24
 2a6:	f8 0a       	sbc	r15, r24
 2a8:	60 81       	ld	r22, Z
 2aa:	c9 01       	movw	r24, r18
 2ac:	0e 94 f2 03 	call	0x7e4	; 0x7e4 <eeprom_write>
        verifySpace();

        length = bufPtr - buff;
        addrPtr = address;
        bufPtr = buff;
        while (length--) {
 2b0:	9d 2d       	mov	r25, r13
          watchdogReset();
          eeprom_write(addrPtr++, *bufPtr++);
 2b2:	97 01       	movw	r18, r14
 2b4:	fe 01       	movw	r30, r28
        verifySpace();

        length = bufPtr - buff;
        addrPtr = address;
        bufPtr = buff;
        while (length--) {
 2b6:	dd 24       	eor	r13, r13
 2b8:	da 94       	dec	r13
 2ba:	d9 0e       	add	r13, r25
 2bc:	91 11       	cpse	r25, r1
 2be:	ed cf       	rjmp	.-38     	; 0x29a <__EEPROM_REGION_LENGTH__+0x9a>
 2c0:	41 c0       	rjmp	.+130    	; 0x344 <__EEPROM_REGION_LENGTH__+0x144>
        }
      }
#endif
    }
    /* Read memory block mode, length is big endian.  */
    else if(ch == STK_READ_PAGE) {
 2c2:	84 37       	cpi	r24, 0x74	; 116
 2c4:	39 f5       	brne	.+78     	; 0x314 <__EEPROM_REGION_LENGTH__+0x114>
      // READ PAGE - we only read flash and EEPROM
      uint8_t type;

      getch();			/* getlen() */
 2c6:	0e 94 a8 01 	call	0x350	; 0x350 <_etext>
      length = getch();
 2ca:	0e 94 a8 01 	call	0x350	; 0x350 <_etext>
 2ce:	c8 2f       	mov	r28, r24
      type = getch();
 2d0:	0e 94 a8 01 	call	0x350	; 0x350 <_etext>
 2d4:	d8 2f       	mov	r29, r24

      verifySpace();
 2d6:	0e 94 2a 04 	call	0x854	; 0x854 <verifySpace>
      /* TODO: putNch */
#ifdef SUPPORT_EEPROM
      if (type == 'F')
 2da:	d6 34       	cpi	r29, 0x46	; 70
 2dc:	41 f4       	brne	.+16     	; 0x2ee <__EEPROM_REGION_LENGTH__+0xee>
          //      while (--length);
          // read a Flash and increment the address (may increment RAMPZ)
          __asm__ ("elpm %0,Z+\n" : "=r" (ch), "=z" (address): "1" (address));
#else
          // read a Flash byte and increment the address
          __asm__ ("lpm %0,Z+\n" : "=r" (ch), "=z" (address): "1" (address));
 2de:	f8 01       	movw	r30, r16
 2e0:	85 91       	lpm	r24, Z+
 2e2:	8f 01       	movw	r16, r30
#endif
          putch(ch);
 2e4:	0e 94 21 03 	call	0x642	; 0x642 <putch>
        } while (--length);
 2e8:	c1 50       	subi	r28, 0x01	; 1
 2ea:	c9 f7       	brne	.-14     	; 0x2de <__EEPROM_REGION_LENGTH__+0xde>
 2ec:	2b c0       	rjmp	.+86     	; 0x344 <__EEPROM_REGION_LENGTH__+0x144>
#ifdef SUPPORT_EEPROM
      else if (type == 'E')
 2ee:	d5 34       	cpi	r29, 0x45	; 69
 2f0:	49 f5       	brne	.+82     	; 0x344 <__EEPROM_REGION_LENGTH__+0x144>
 2f2:	0b c0       	rjmp	.+22     	; 0x30a <__EEPROM_REGION_LENGTH__+0x10a>
        while (length--)
          putch(eeprom_read(address++));
 2f4:	78 01       	movw	r14, r16
 2f6:	ef ef       	ldi	r30, 0xFF	; 255
 2f8:	ee 1a       	sub	r14, r30
 2fa:	fe 0a       	sbc	r15, r30
 2fc:	c8 01       	movw	r24, r16
 2fe:	0e 94 34 04 	call	0x868	; 0x868 <eeprom_read>
 302:	0e 94 21 03 	call	0x642	; 0x642 <putch>
#endif
          putch(ch);
        } while (--length);
#ifdef SUPPORT_EEPROM
      else if (type == 'E')
        while (length--)
 306:	cd 2f       	mov	r28, r29
          putch(eeprom_read(address++));
 308:	87 01       	movw	r16, r14
#endif
          putch(ch);
        } while (--length);
#ifdef SUPPORT_EEPROM
      else if (type == 'E')
        while (length--)
 30a:	df ef       	ldi	r29, 0xFF	; 255
 30c:	dc 0f       	add	r29, r28
 30e:	c1 11       	cpse	r28, r1
 310:	f1 cf       	rjmp	.-30     	; 0x2f4 <__EEPROM_REGION_LENGTH__+0xf4>
 312:	18 c0       	rjmp	.+48     	; 0x344 <__EEPROM_REGION_LENGTH__+0x144>
          putch(eeprom_read(address++));
#endif
    }

    /* Get device signature bytes  */
    else if(ch == STK_READ_SIGN) {
 314:	85 37       	cpi	r24, 0x75	; 117
 316:	61 f4       	brne	.+24     	; 0x330 <__EEPROM_REGION_LENGTH__+0x130>
      // READ SIGN - return what Avrdude wants to hear
      verifySpace();
 318:	0e 94 2a 04 	call	0x854	; 0x854 <verifySpace>
      putch(SIGNATURE_0);
 31c:	8e e1       	ldi	r24, 0x1E	; 30
 31e:	0e 94 21 03 	call	0x642	; 0x642 <putch>
      putch(SIGNATURE_1);
 322:	84 e9       	ldi	r24, 0x94	; 148
 324:	0e 94 21 03 	call	0x642	; 0x642 <putch>
      putch(SIGNATURE_2);
 328:	86 e0       	ldi	r24, 0x06	; 6
 32a:	0e 94 21 03 	call	0x642	; 0x642 <putch>
 32e:	0a c0       	rjmp	.+20     	; 0x344 <__EEPROM_REGION_LENGTH__+0x144>
    }
    else if (ch == STK_LEAVE_PROGMODE) { /* 'Q' */
 330:	81 35       	cpi	r24, 0x51	; 81
 332:	31 f4       	brne	.+12     	; 0x340 <__EEPROM_REGION_LENGTH__+0x140>
      // Adaboot no-wait mod
      watchdogConfig(WATCHDOG_16MS);
 334:	88 e0       	ldi	r24, 0x08	; 8
 336:	0e 94 5c 04 	call	0x8b8	; 0x8b8 <watchdogConfig>
      verifySpace();
 33a:	0e 94 2a 04 	call	0x854	; 0x854 <verifySpace>
 33e:	02 c0       	rjmp	.+4      	; 0x344 <__EEPROM_REGION_LENGTH__+0x144>
    }
    else {
      // This covers the response to commands like STK_ENTER_PROGMODE
      verifySpace();
 340:	0e 94 2a 04 	call	0x854	; 0x854 <verifySpace>
    }
    putch(STK_OK);
 344:	80 e1       	ldi	r24, 0x10	; 16
 346:	0e 94 21 03 	call	0x642	; 0x642 <putch>
  }
 34a:	f4 ce       	rjmp	.-536    	; 0x134 <clchk+0x38>

0000034c <_exit>:
 34c:	f8 94       	cli

0000034e <__stop_program>:
 34e:	ff cf       	rjmp	.-2      	; 0x34e <__stop_program>

Disassembly of section .text:

000008d8 <__bad_interrupt>:
 8d8:	0c 94 00 00 	jmp	0	; 0x0 <__TEXT_REGION_ORIGIN__>

Disassembly of section .text.eeprom_write:

000007e4 <eeprom_write>:
# define UART_SRL UBRR3L
# define UART_UDR UDR3
#endif

static void eeprom_write(uint16_t addr, uint8_t val) {
  while (!eeprom_is_ready());
 7e4:	f9 99       	sbic	0x1f, 1	; 31
 7e6:	fe cf       	rjmp	.-4      	; 0x7e4 <eeprom_write>

  EEAR = addr;
 7e8:	92 bd       	out	0x22, r25	; 34
 7ea:	81 bd       	out	0x21, r24	; 33
  EEDR = val;
 7ec:	60 bd       	out	0x20, r22	; 32
  EECR |= 1 << EEMPE;	/* Write logical one to EEMPE */
 7ee:	8f b3       	in	r24, 0x1f	; 31
 7f0:	84 60       	ori	r24, 0x04	; 4
 7f2:	8f bb       	out	0x1f, r24	; 31
  EECR |= 1 << EEPE;	/* Start eeprom write by setting EEPE */
 7f4:	8f b3       	in	r24, 0x1f	; 31
 7f6:	82 60       	ori	r24, 0x02	; 2
 7f8:	8f bb       	out	0x1f, r24	; 31
 7fa:	08 95       	ret

Disassembly of section .text.eeprom_read:

00000868 <eeprom_read>:
}

static uint8_t eeprom_read(uint16_t addr) {
  while (!eeprom_is_ready());
 868:	f9 99       	sbic	0x1f, 1	; 31
 86a:	fe cf       	rjmp	.-4      	; 0x868 <eeprom_read>

  EEAR = addr;
 86c:	92 bd       	out	0x22, r25	; 34
 86e:	81 bd       	out	0x21, r24	; 33
  EECR |= 1 << EERE;	/* Start eeprom read by writing EERE */
 870:	8f b3       	in	r24, 0x1f	; 31
 872:	81 60       	ori	r24, 0x01	; 1
 874:	8f bb       	out	0x1f, r24	; 31

  return EEDR;
 876:	80 b5       	in	r24, 0x20	; 32
}
 878:	08 95       	ret

Disassembly of section .text.spi_mode:

0000087a <spi_mode>:
#define MOSI_PIN	(1 << 3)
#define SS_PIN		(1 << 2)

static void spi_mode(uint8_t mode) {
	/* Enable SPI master with configuration byte specified */
	SPCR = 0;
 87a:	1c bc       	out	0x2c, r1	; 44
	SPCR = (mode & 0x7F) | (1 << SPE) | (1 << MSTR);
 87c:	8f 72       	andi	r24, 0x2F	; 47
 87e:	80 65       	ori	r24, 0x50	; 80
 880:	8c bd       	out	0x2c, r24	; 44
	SPSR = 1 << SPI2X; /* double speed */
 882:	81 e0       	ldi	r24, 0x01	; 1
 884:	8d bd       	out	0x2d, r24	; 45
	(void) SPSR;
 886:	8d b5       	in	r24, 0x2d	; 45
	(void) SPDR;
 888:	8e b5       	in	r24, 0x2e	; 46
 88a:	08 95       	ret

Disassembly of section .text.spi_init:

000007b0 <spi_init>:
}

static void spi_init(void) {
	/* Initialize the SPI pins: SCK & MOSI as outputs, MISO as input */
	SPI_DDR |= SCK_PIN | MOSI_PIN;
 7b0:	84 b1       	in	r24, 0x04	; 4
 7b2:	88 62       	ori	r24, 0x28	; 40
 7b4:	84 b9       	out	0x04, r24	; 4
	SPI_DDR &= ~MISO_PIN;
 7b6:	84 b1       	in	r24, 0x04	; 4
 7b8:	8f 7e       	andi	r24, 0xEF	; 239
 7ba:	84 b9       	out	0x04, r24	; 4
	/* Must also pre-set SS to output, otherwise it's going to bite us */
	SPI_DDR |= SS_PIN;
 7bc:	84 b1       	in	r24, 0x04	; 4
 7be:	84 60       	ori	r24, 0x04	; 4
 7c0:	84 b9       	out	0x04, r24	; 4

	/* Enable SPI Master, MSB, SPI mode 0, FOSC/4 */
	spi_mode(0);
 7c2:	80 e0       	ldi	r24, 0x00	; 0
 7c4:	0e 94 3d 04 	call	0x87a	; 0x87a <spi_mode>
 7c8:	08 95       	ret

Disassembly of section .text.spi_transfer:

000007fc <spi_transfer>:
}

static uint8_t spi_transfer(uint8_t value) {
	uint8_t cnt = 0xff;
	SPDR = value;
 7fc:	8e bd       	out	0x2e, r24	; 46
	/* Enable SPI Master, MSB, SPI mode 0, FOSC/4 */
	spi_mode(0);
}

static uint8_t spi_transfer(uint8_t value) {
	uint8_t cnt = 0xff;
 7fe:	8f ef       	ldi	r24, 0xFF	; 255
	SPDR = value;
	while (cnt -- && !(SPSR & (1 << SPIF)));
 800:	9f ef       	ldi	r25, 0xFF	; 255
 802:	98 0f       	add	r25, r24
 804:	88 23       	and	r24, r24
 806:	21 f0       	breq	.+8      	; 0x810 <spi_transfer+0x14>
 808:	89 2f       	mov	r24, r25
 80a:	0d b4       	in	r0, 0x2d	; 45
 80c:	07 fe       	sbrs	r0, 7
 80e:	f8 cf       	rjmp	.-16     	; 0x800 <spi_transfer+0x4>
	return SPDR;
 810:	8e b5       	in	r24, 0x2e	; 46
}
 812:	08 95       	ret

Disassembly of section .text.delay8:

00000738 <delay8>:
	else
		CSN_PORT &= ~CSN_PIN;
}

static void delay8(uint16_t count) {
	while (count --)
 738:	09 c0       	rjmp	.+18     	; 0x74c <delay8+0x14>
	...
		__asm__ __volatile__ (
 746:	00 00       	nop
 748:	a8 95       	wdr
	else
		CSN_PORT &= ~CSN_PIN;
}

static void delay8(uint16_t count) {
	while (count --)
 74a:	c9 01       	movw	r24, r18
 74c:	9c 01       	movw	r18, r24
 74e:	21 50       	subi	r18, 0x01	; 1
 750:	31 09       	sbc	r19, r1
 752:	89 2b       	or	r24, r25
 754:	91 f7       	brne	.-28     	; 0x73a <delay8+0x2>
			"\tnop\n"
			"\tnop\n"
			"\tnop\n"
			"\twdr\n"
		);
}
 756:	08 95       	ret

Disassembly of section .text.nrf24_read_reg:

00000814 <nrf24_read_reg>:

static inline void nrf24_csn(uint8_t level) {
	if (level)
		CSN_PORT |= CSN_PIN;
	else
		CSN_PORT &= ~CSN_PIN;
 814:	95 b1       	in	r25, 0x05	; 5
 816:	9b 7f       	andi	r25, 0xFB	; 251
 818:	95 b9       	out	0x05, r25	; 5
static uint8_t nrf24_read_reg(uint8_t addr) {
	uint8_t ret;

	nrf24_csn(0);

	spi_transfer(addr | R_REGISTER);
 81a:	0e 94 fe 03 	call	0x7fc	; 0x7fc <spi_transfer>
	ret = spi_transfer(0);
 81e:	80 e0       	ldi	r24, 0x00	; 0
 820:	0e 94 fe 03 	call	0x7fc	; 0x7fc <spi_transfer>
 */
#include "nRF24L01.h"

static inline void nrf24_csn(uint8_t level) {
	if (level)
		CSN_PORT |= CSN_PIN;
 824:	95 b1       	in	r25, 0x05	; 5
 826:	94 60       	ori	r25, 0x04	; 4
 828:	95 b9       	out	0x05, r25	; 5
	ret = spi_transfer(0);

	nrf24_csn(1);

	return ret;
}
 82a:	08 95       	ret

Disassembly of section .text.nrf24_write_reg:

00000758 <nrf24_write_reg>:

static void nrf24_write_reg(uint8_t addr, uint8_t value) {
 758:	cf 93       	push	r28
 75a:	c6 2f       	mov	r28, r22

static inline void nrf24_csn(uint8_t level) {
	if (level)
		CSN_PORT |= CSN_PIN;
	else
		CSN_PORT &= ~CSN_PIN;
 75c:	95 b1       	in	r25, 0x05	; 5
 75e:	9b 7f       	andi	r25, 0xFB	; 251
 760:	95 b9       	out	0x05, r25	; 5
}

static void nrf24_write_reg(uint8_t addr, uint8_t value) {
	nrf24_csn(0);

	spi_transfer(addr | W_REGISTER);
 762:	80 62       	ori	r24, 0x20	; 32
 764:	0e 94 fe 03 	call	0x7fc	; 0x7fc <spi_transfer>
	spi_transfer(value);
 768:	8c 2f       	mov	r24, r28
 76a:	0e 94 fe 03 	call	0x7fc	; 0x7fc <spi_transfer>
 */
#include "nRF24L01.h"

static inline void nrf24_csn(uint8_t level) {
	if (level)
		CSN_PORT |= CSN_PIN;
 76e:	85 b1       	in	r24, 0x05	; 5
 770:	84 60       	ori	r24, 0x04	; 4
 772:	85 b9       	out	0x05, r24	; 5

	spi_transfer(addr | W_REGISTER);
	spi_transfer(value);

	nrf24_csn(1);
}
 774:	cf 91       	pop	r28
 776:	08 95       	ret

Disassembly of section .text.nrf24_read_status:

0000082c <nrf24_read_status>:

static inline void nrf24_csn(uint8_t level) {
	if (level)
		CSN_PORT |= CSN_PIN;
	else
		CSN_PORT &= ~CSN_PIN;
 82c:	85 b1       	in	r24, 0x05	; 5
 82e:	8b 7f       	andi	r24, 0xFB	; 251
 830:	85 b9       	out	0x05, r24	; 5
static uint8_t nrf24_read_status(void) {
	uint8_t ret;

	nrf24_csn(0);

	ret = spi_transfer(NOP);
 832:	8f ef       	ldi	r24, 0xFF	; 255
 834:	0e 94 fe 03 	call	0x7fc	; 0x7fc <spi_transfer>
 */
#include "nRF24L01.h"

static inline void nrf24_csn(uint8_t level) {
	if (level)
		CSN_PORT |= CSN_PIN;
 838:	95 b1       	in	r25, 0x05	; 5
 83a:	94 60       	ori	r25, 0x04	; 4
 83c:	95 b9       	out	0x05, r25	; 5
	ret = spi_transfer(NOP);

	nrf24_csn(1);

	return ret;
}
 83e:	08 95       	ret

Disassembly of section .text.nrf24_write_addr_reg:

000006dc <nrf24_write_addr_reg>:

static void nrf24_write_addr_reg(uint8_t addr, uint8_t value[3]) {
 6dc:	cf 93       	push	r28
 6de:	df 93       	push	r29
 6e0:	eb 01       	movw	r28, r22

static inline void nrf24_csn(uint8_t level) {
	if (level)
		CSN_PORT |= CSN_PIN;
	else
		CSN_PORT &= ~CSN_PIN;
 6e2:	95 b1       	in	r25, 0x05	; 5
 6e4:	9b 7f       	andi	r25, 0xFB	; 251
 6e6:	95 b9       	out	0x05, r25	; 5
}

static void nrf24_write_addr_reg(uint8_t addr, uint8_t value[3]) {
	nrf24_csn(0);

	spi_transfer(addr | W_REGISTER);
 6e8:	80 62       	ori	r24, 0x20	; 32
 6ea:	0e 94 fe 03 	call	0x7fc	; 0x7fc <spi_transfer>
	spi_transfer(value[0]);
 6ee:	88 81       	ld	r24, Y
 6f0:	0e 94 fe 03 	call	0x7fc	; 0x7fc <spi_transfer>
	spi_transfer(value[1]);
 6f4:	89 81       	ldd	r24, Y+1	; 0x01
 6f6:	0e 94 fe 03 	call	0x7fc	; 0x7fc <spi_transfer>
	spi_transfer(value[2]);
 6fa:	8a 81       	ldd	r24, Y+2	; 0x02
 6fc:	0e 94 fe 03 	call	0x7fc	; 0x7fc <spi_transfer>
 */
#include "nRF24L01.h"

static inline void nrf24_csn(uint8_t level) {
	if (level)
		CSN_PORT |= CSN_PIN;
 700:	85 b1       	in	r24, 0x05	; 5
 702:	84 60       	ori	r24, 0x04	; 4
 704:	85 b9       	out	0x05, r24	; 5
	spi_transfer(value[0]);
	spi_transfer(value[1]);
	spi_transfer(value[2]);

	nrf24_csn(1);
}
 706:	df 91       	pop	r29
 708:	cf 91       	pop	r28
 70a:	08 95       	ret

Disassembly of section .text.nrf24_tx_flush:

00000840 <nrf24_tx_flush>:

static inline void nrf24_csn(uint8_t level) {
	if (level)
		CSN_PORT |= CSN_PIN;
	else
		CSN_PORT &= ~CSN_PIN;
 840:	85 b1       	in	r24, 0x05	; 5
 842:	8b 7f       	andi	r24, 0xFB	; 251
 844:	85 b9       	out	0x05, r24	; 5
static uint8_t nrf24_tx_flush(void) {
	uint8_t ret;

	nrf24_csn(0);

	ret = spi_transfer(FLUSH_TX);
 846:	81 ee       	ldi	r24, 0xE1	; 225
 848:	0e 94 fe 03 	call	0x7fc	; 0x7fc <spi_transfer>
 */
#include "nRF24L01.h"

static inline void nrf24_csn(uint8_t level) {
	if (level)
		CSN_PORT |= CSN_PIN;
 84c:	95 b1       	in	r25, 0x05	; 5
 84e:	94 60       	ori	r25, 0x04	; 4
 850:	95 b9       	out	0x05, r25	; 5
	ret = spi_transfer(FLUSH_TX);

	nrf24_csn(1);

	return ret;
}
 852:	08 95       	ret

Disassembly of section .text.nrf24_delay:

000008c4 <nrf24_delay>:

static void nrf24_delay(void) {
	my_delay(5000);
 8c4:	88 e8       	ldi	r24, 0x88	; 136
 8c6:	93 e1       	ldi	r25, 0x13	; 19
 8c8:	0e 94 9c 03 	call	0x738	; 0x738 <delay8>
 8cc:	08 95       	ret

Disassembly of section .text.nrf24_init:

000004f0 <nrf24_init>:
#define CONFIG_VAL ((1 << MASK_RX_DR) | (1 << MASK_TX_DS) | \
		(1 << MASK_MAX_RT) | (1 << CRCO) | (1 << EN_CRC))

static int nrf24_init(void) {
	/* CE and CSN are outputs */
	CE_DDR |= CE_PIN;
 4f0:	84 b1       	in	r24, 0x04	; 4
 4f2:	82 60       	ori	r24, 0x02	; 2
 4f4:	84 b9       	out	0x04, r24	; 4
	CSN_DDR |= CSN_PIN;
 4f6:	84 b1       	in	r24, 0x04	; 4
 4f8:	84 60       	ori	r24, 0x04	; 4
 4fa:	84 b9       	out	0x04, r24	; 4
#else
	/* This should take at least 10us (rising) or 200us (falling) */
	if (level)
		my_delay(10);
	else
		my_delay(200);
 4fc:	88 ec       	ldi	r24, 0xC8	; 200
 4fe:	90 e0       	ldi	r25, 0x00	; 0
 500:	0e 94 9c 03 	call	0x738	; 0x738 <delay8>
#endif

	if (level)
		CE_PORT |= CE_PIN;
	else
		CE_PORT &= ~CE_PIN;
 504:	85 b1       	in	r24, 0x05	; 5
 506:	8d 7f       	andi	r24, 0xFD	; 253
 508:	85 b9       	out	0x05, r24	; 5
 */
#include "nRF24L01.h"

static inline void nrf24_csn(uint8_t level) {
	if (level)
		CSN_PORT |= CSN_PIN;
 50a:	85 b1       	in	r24, 0x05	; 5
 50c:	84 60       	ori	r24, 0x04	; 4
 50e:	85 b9       	out	0x05, r24	; 5
	CE_DDR |= CE_PIN;
	CSN_DDR |= CSN_PIN;

	nrf24_ce(0);
	nrf24_csn(1);
	nrf24_delay();
 510:	0e 94 62 04 	call	0x8c4	; 0x8c4 <nrf24_delay>

	/* 2ms interval, 15 retries (16 total) */
	nrf24_write_reg(SETUP_RETR, 0x7f);
 514:	6f e7       	ldi	r22, 0x7F	; 127
 516:	84 e0       	ldi	r24, 0x04	; 4
 518:	0e 94 ac 03 	call	0x758	; 0x758 <nrf24_write_reg>
	if (nrf24_read_reg(SETUP_RETR) != 0x7f)
 51c:	84 e0       	ldi	r24, 0x04	; 4
 51e:	0e 94 0a 04 	call	0x814	; 0x814 <nrf24_read_reg>
 522:	8f 37       	cpi	r24, 0x7F	; 127
 524:	f9 f4       	brne	.+62     	; 0x564 <__stack+0x65>
		return 1; /* There may be no nRF24 connected */

	/* Maximum Tx power, 250kbps data rate */
	nrf24_write_reg(RF_SETUP, (1 << RF_PWR_LOW) | (1 << RF_PWR_HIGH) |
 526:	66 e2       	ldi	r22, 0x26	; 38
 528:	86 e0       	ldi	r24, 0x06	; 6
 52a:	0e 94 ac 03 	call	0x758	; 0x758 <nrf24_write_reg>
			(1 << RF_DR_LOW));
	/* Dynamic payload length for TX & RX (pipes 0 and 1) */
	nrf24_write_reg(DYNPD, 0x03);
 52e:	63 e0       	ldi	r22, 0x03	; 3
 530:	8c e1       	ldi	r24, 0x1C	; 28
 532:	0e 94 ac 03 	call	0x758	; 0x758 <nrf24_write_reg>
	nrf24_write_reg(FEATURE, 1 << EN_DPL);
 536:	64 e0       	ldi	r22, 0x04	; 4
 538:	8d e1       	ldi	r24, 0x1D	; 29
 53a:	0e 94 ac 03 	call	0x758	; 0x758 <nrf24_write_reg>
	/* Reset status bits */
	nrf24_write_reg(STATUS, (1 << RX_DR) | (1 << TX_DS) | (1 << MAX_RT));
 53e:	60 e7       	ldi	r22, 0x70	; 112
 540:	87 e0       	ldi	r24, 0x07	; 7
 542:	0e 94 ac 03 	call	0x758	; 0x758 <nrf24_write_reg>
	/* Set some RF channel number */
	nrf24_write_reg(RF_CH, 42);
 546:	6a e2       	ldi	r22, 0x2A	; 42
 548:	85 e0       	ldi	r24, 0x05	; 5
 54a:	0e 94 ac 03 	call	0x758	; 0x758 <nrf24_write_reg>
	/* 3-byte addresses */
	nrf24_write_reg(SETUP_AW, 0x01);
 54e:	61 e0       	ldi	r22, 0x01	; 1
 550:	83 e0       	ldi	r24, 0x03	; 3
 552:	0e 94 ac 03 	call	0x758	; 0x758 <nrf24_write_reg>
	/* Enable ACKing on both pipe 0 & 1 for TX & RX ACK support */
	nrf24_write_reg(EN_AA, 0x03);
 556:	63 e0       	ldi	r22, 0x03	; 3
 558:	81 e0       	ldi	r24, 0x01	; 1
 55a:	0e 94 ac 03 	call	0x758	; 0x758 <nrf24_write_reg>

	return 0;
 55e:	80 e0       	ldi	r24, 0x00	; 0
 560:	90 e0       	ldi	r25, 0x00	; 0
 562:	08 95       	ret
	nrf24_delay();

	/* 2ms interval, 15 retries (16 total) */
	nrf24_write_reg(SETUP_RETR, 0x7f);
	if (nrf24_read_reg(SETUP_RETR) != 0x7f)
		return 1; /* There may be no nRF24 connected */
 564:	81 e0       	ldi	r24, 0x01	; 1
 566:	90 e0       	ldi	r25, 0x00	; 0
	nrf24_write_reg(SETUP_AW, 0x01);
	/* Enable ACKing on both pipe 0 & 1 for TX & RX ACK support */
	nrf24_write_reg(EN_AA, 0x03);

	return 0;
}
 568:	08 95       	ret

Disassembly of section .text.nrf24_set_rx_addr:

000008ce <nrf24_set_rx_addr>:

static void nrf24_set_rx_addr(uint8_t addr[3]) {
	nrf24_write_addr_reg(RX_ADDR_P1, addr);
 8ce:	bc 01       	movw	r22, r24
 8d0:	8b e0       	ldi	r24, 0x0B	; 11
 8d2:	0e 94 6e 03 	call	0x6dc	; 0x6dc <nrf24_write_addr_reg>
 8d6:	08 95       	ret

Disassembly of section .text.nrf24_set_tx_addr:

00000778 <nrf24_set_tx_addr>:
}

static void nrf24_set_tx_addr(uint8_t addr[3]) {
 778:	cf 93       	push	r28
 77a:	df 93       	push	r29
 77c:	ec 01       	movw	r28, r24
	nrf24_write_addr_reg(TX_ADDR, addr);
 77e:	bc 01       	movw	r22, r24
 780:	80 e1       	ldi	r24, 0x10	; 16
 782:	0e 94 6e 03 	call	0x6dc	; 0x6dc <nrf24_write_addr_reg>
	/* The pipe 0 address is the address we listen on for ACKs */
	nrf24_write_addr_reg(RX_ADDR_P0, addr);
 786:	be 01       	movw	r22, r28
 788:	8a e0       	ldi	r24, 0x0A	; 10
 78a:	0e 94 6e 03 	call	0x6dc	; 0x6dc <nrf24_write_addr_reg>
}
 78e:	df 91       	pop	r29
 790:	cf 91       	pop	r28
 792:	08 95       	ret

Disassembly of section .text.nrf24_rx_mode:

0000070c <nrf24_rx_mode>:

static uint8_t nrf24_in_rx = 0;

static void nrf24_rx_mode(void) {
	if (nrf24_in_rx)
 70c:	80 91 43 01 	lds	r24, 0x0143	; 0x800143 <nrf24_in_rx>
 710:	81 11       	cpse	r24, r1
 712:	11 c0       	rjmp	.+34     	; 0x736 <nrf24_rx_mode+0x2a>
		return;

	/* Rx mode */
	nrf24_write_reg(CONFIG, CONFIG_VAL | (1 << PWR_UP) | (1 << PRIM_RX));
 714:	6f e7       	ldi	r22, 0x7F	; 127
 716:	0e 94 ac 03 	call	0x758	; 0x758 <nrf24_write_reg>
	/* Only use data pipe 1 for receiving, pipe 0 is for TX ACKs */
	nrf24_write_reg(EN_RXADDR, 0x02);
 71a:	62 e0       	ldi	r22, 0x02	; 2
 71c:	82 e0       	ldi	r24, 0x02	; 2
 71e:	0e 94 ac 03 	call	0x758	; 0x758 <nrf24_write_reg>
	else
		while (timer_read() - prev_ce_edge <= F_CPU / 5000);
#else
	/* This should take at least 10us (rising) or 200us (falling) */
	if (level)
		my_delay(10);
 722:	8a e0       	ldi	r24, 0x0A	; 10
 724:	90 e0       	ldi	r25, 0x00	; 0
 726:	0e 94 9c 03 	call	0x738	; 0x738 <delay8>
	else
		my_delay(200);
#endif

	if (level)
		CE_PORT |= CE_PIN;
 72a:	85 b1       	in	r24, 0x05	; 5
 72c:	82 60       	ori	r24, 0x02	; 2
 72e:	85 b9       	out	0x05, r24	; 5
	/* Only use data pipe 1 for receiving, pipe 0 is for TX ACKs */
	nrf24_write_reg(EN_RXADDR, 0x02);

	nrf24_ce(1);

	nrf24_in_rx = 1;
 730:	81 e0       	ldi	r24, 0x01	; 1
 732:	80 93 43 01 	sts	0x0143, r24	; 0x800143 <nrf24_in_rx>
 736:	08 95       	ret

Disassembly of section .text.nrf24_idle_mode:

00000696 <nrf24_idle_mode>:
/*
 * This switches out of Rx mode and leaves the chip in Standby if desired.
 * Otherwise the chip is powered off.  In Standby a new operation will
 * start faster but more current is consumed while waiting.
 */
static void nrf24_idle_mode(uint8_t standby) {
 696:	cf 93       	push	r28
 698:	c8 2f       	mov	r28, r24
	if (nrf24_in_rx) {
 69a:	80 91 43 01 	lds	r24, 0x0143	; 0x800143 <nrf24_in_rx>
 69e:	88 23       	and	r24, r24
 6a0:	71 f0       	breq	.+28     	; 0x6be <nrf24_idle_mode+0x28>
#else
	/* This should take at least 10us (rising) or 200us (falling) */
	if (level)
		my_delay(10);
	else
		my_delay(200);
 6a2:	88 ec       	ldi	r24, 0xC8	; 200
 6a4:	90 e0       	ldi	r25, 0x00	; 0
 6a6:	0e 94 9c 03 	call	0x738	; 0x738 <delay8>
#endif

	if (level)
		CE_PORT |= CE_PIN;
	else
		CE_PORT &= ~CE_PIN;
 6aa:	85 b1       	in	r24, 0x05	; 5
 6ac:	8d 7f       	andi	r24, 0xFD	; 253
 6ae:	85 b9       	out	0x05, r24	; 5
 */
static void nrf24_idle_mode(uint8_t standby) {
	if (nrf24_in_rx) {
		nrf24_ce(0);

		if (!standby)
 6b0:	c1 11       	cpse	r28, r1
 6b2:	10 c0       	rjmp	.+32     	; 0x6d4 <nrf24_idle_mode+0x3e>
			nrf24_write_reg(CONFIG, CONFIG_VAL);
 6b4:	6c e7       	ldi	r22, 0x7C	; 124
 6b6:	80 e0       	ldi	r24, 0x00	; 0
 6b8:	0e 94 ac 03 	call	0x758	; 0x758 <nrf24_write_reg>
 6bc:	0b c0       	rjmp	.+22     	; 0x6d4 <nrf24_idle_mode+0x3e>
	} else {
		if (standby)
 6be:	cc 23       	and	r28, r28
 6c0:	29 f0       	breq	.+10     	; 0x6cc <nrf24_idle_mode+0x36>
			nrf24_write_reg(CONFIG, CONFIG_VAL | (1 << PWR_UP));
 6c2:	6e e7       	ldi	r22, 0x7E	; 126
 6c4:	80 e0       	ldi	r24, 0x00	; 0
 6c6:	0e 94 ac 03 	call	0x758	; 0x758 <nrf24_write_reg>
 6ca:	04 c0       	rjmp	.+8      	; 0x6d4 <nrf24_idle_mode+0x3e>
		else
			nrf24_write_reg(CONFIG, CONFIG_VAL);
 6cc:	6c e7       	ldi	r22, 0x7C	; 124
 6ce:	80 e0       	ldi	r24, 0x00	; 0
 6d0:	0e 94 ac 03 	call	0x758	; 0x758 <nrf24_write_reg>
	}

	nrf24_in_rx = 0;
 6d4:	10 92 43 01 	sts	0x0143, r1	; 0x800143 <nrf24_in_rx>
}
 6d8:	cf 91       	pop	r28
 6da:	08 95       	ret

Disassembly of section .text.nrf24_rx_fifo_data:

0000089c <nrf24_rx_fifo_data>:
static uint8_t nrf24_rx_new_data(void) {
	return (nrf24_read_status() >> RX_DR) & 1;
}

static uint8_t nrf24_rx_fifo_data(void) {
	return !(nrf24_read_reg(FIFO_STATUS) & (1 << RX_EMPTY));
 89c:	87 e1       	ldi	r24, 0x17	; 23
 89e:	0e 94 0a 04 	call	0x814	; 0x814 <nrf24_read_reg>
 8a2:	91 e0       	ldi	r25, 0x01	; 1
 8a4:	89 27       	eor	r24, r25
}
 8a6:	81 70       	andi	r24, 0x01	; 1
 8a8:	08 95       	ret

Disassembly of section .text.nrf24_rx_data_avail:

000007ca <nrf24_rx_data_avail>:

static inline void nrf24_csn(uint8_t level) {
	if (level)
		CSN_PORT |= CSN_PIN;
	else
		CSN_PORT &= ~CSN_PIN;
 7ca:	85 b1       	in	r24, 0x05	; 5
 7cc:	8b 7f       	andi	r24, 0xFB	; 251
 7ce:	85 b9       	out	0x05, r24	; 5
static uint8_t nrf24_rx_data_avail(void) {
	uint8_t ret;

	nrf24_csn(0);

	spi_transfer(R_RX_PL_WID);
 7d0:	80 e6       	ldi	r24, 0x60	; 96
 7d2:	0e 94 fe 03 	call	0x7fc	; 0x7fc <spi_transfer>
	ret = spi_transfer(0);
 7d6:	80 e0       	ldi	r24, 0x00	; 0
 7d8:	0e 94 fe 03 	call	0x7fc	; 0x7fc <spi_transfer>
 */
#include "nRF24L01.h"

static inline void nrf24_csn(uint8_t level) {
	if (level)
		CSN_PORT |= CSN_PIN;
 7dc:	95 b1       	in	r25, 0x05	; 5
 7de:	94 60       	ori	r25, 0x04	; 4
 7e0:	95 b9       	out	0x05, r25	; 5
	ret = spi_transfer(0);

	nrf24_csn(1);

	return ret;
}
 7e2:	08 95       	ret

Disassembly of section .text.nrf24_rx_read:

000005e0 <nrf24_rx_read>:

static void nrf24_rx_read(uint8_t *buf, uint8_t *pkt_len) {
 5e0:	ef 92       	push	r14
 5e2:	ff 92       	push	r15
 5e4:	0f 93       	push	r16
 5e6:	1f 93       	push	r17
 5e8:	cf 93       	push	r28
 5ea:	df 93       	push	r29
 5ec:	8c 01       	movw	r16, r24
 5ee:	7b 01       	movw	r14, r22
	uint8_t len;

	nrf24_write_reg(STATUS, 1 << RX_DR);
 5f0:	60 e4       	ldi	r22, 0x40	; 64
 5f2:	87 e0       	ldi	r24, 0x07	; 7
 5f4:	0e 94 ac 03 	call	0x758	; 0x758 <nrf24_write_reg>

	len = nrf24_rx_data_avail();
 5f8:	0e 94 e5 03 	call	0x7ca	; 0x7ca <nrf24_rx_data_avail>
 5fc:	c8 2f       	mov	r28, r24
	*pkt_len = len;
 5fe:	f7 01       	movw	r30, r14
 600:	80 83       	st	Z, r24

static inline void nrf24_csn(uint8_t level) {
	if (level)
		CSN_PORT |= CSN_PIN;
	else
		CSN_PORT &= ~CSN_PIN;
 602:	85 b1       	in	r24, 0x05	; 5
 604:	8b 7f       	andi	r24, 0xFB	; 251
 606:	85 b9       	out	0x05, r24	; 5
	len = nrf24_rx_data_avail();
	*pkt_len = len;

	nrf24_csn(0);

	spi_transfer(R_RX_PAYLOAD);
 608:	81 e6       	ldi	r24, 0x61	; 97
 60a:	0e 94 fe 03 	call	0x7fc	; 0x7fc <spi_transfer>
	while (len --)
 60e:	0b c0       	rjmp	.+22     	; 0x626 <nrf24_rx_read+0x46>
		*buf ++ = spi_transfer(0);
 610:	78 01       	movw	r14, r16
 612:	ff ef       	ldi	r31, 0xFF	; 255
 614:	ef 1a       	sub	r14, r31
 616:	ff 0a       	sbc	r15, r31
 618:	80 e0       	ldi	r24, 0x00	; 0
 61a:	0e 94 fe 03 	call	0x7fc	; 0x7fc <spi_transfer>
 61e:	f8 01       	movw	r30, r16
 620:	80 83       	st	Z, r24
	*pkt_len = len;

	nrf24_csn(0);

	spi_transfer(R_RX_PAYLOAD);
	while (len --)
 622:	cd 2f       	mov	r28, r29
		*buf ++ = spi_transfer(0);
 624:	87 01       	movw	r16, r14
	*pkt_len = len;

	nrf24_csn(0);

	spi_transfer(R_RX_PAYLOAD);
	while (len --)
 626:	df ef       	ldi	r29, 0xFF	; 255
 628:	dc 0f       	add	r29, r28
 62a:	c1 11       	cpse	r28, r1
 62c:	f1 cf       	rjmp	.-30     	; 0x610 <nrf24_rx_read+0x30>
 */
#include "nRF24L01.h"

static inline void nrf24_csn(uint8_t level) {
	if (level)
		CSN_PORT |= CSN_PIN;
 62e:	85 b1       	in	r24, 0x05	; 5
 630:	84 60       	ori	r24, 0x04	; 4
 632:	85 b9       	out	0x05, r24	; 5
	spi_transfer(R_RX_PAYLOAD);
	while (len --)
		*buf ++ = spi_transfer(0);

	nrf24_csn(1);
}
 634:	df 91       	pop	r29
 636:	cf 91       	pop	r28
 638:	1f 91       	pop	r17
 63a:	0f 91       	pop	r16
 63c:	ff 90       	pop	r15
 63e:	ef 90       	pop	r14
 640:	08 95       	ret

Disassembly of section .text.nrf24_tx:

000003f0 <nrf24_tx>:

static void nrf24_tx(uint8_t *buf, uint8_t len) {
 3f0:	ef 92       	push	r14
 3f2:	ff 92       	push	r15
 3f4:	0f 93       	push	r16
 3f6:	1f 93       	push	r17
 3f8:	cf 93       	push	r28
 3fa:	df 93       	push	r29
 3fc:	8c 01       	movw	r16, r24
 3fe:	c6 2f       	mov	r28, r22
	/*
	 * The user may have put the chip out of Rx mode to perform a
	 * few Tx operations in a row, or they may have left the chip
	 * in Rx which we'll switch back on when this Tx is done.
	 */
	if (nrf24_in_rx) {
 400:	80 91 43 01 	lds	r24, 0x0143	; 0x800143 <nrf24_in_rx>
 404:	88 23       	and	r24, r24
 406:	31 f0       	breq	.+12     	; 0x414 <__DATA_REGION_LENGTH__+0x14>
		nrf24_idle_mode(1);
 408:	81 e0       	ldi	r24, 0x01	; 1
 40a:	0e 94 4b 03 	call	0x696	; 0x696 <nrf24_idle_mode>

		nrf24_in_rx = 1;
 40e:	81 e0       	ldi	r24, 0x01	; 1
 410:	80 93 43 01 	sts	0x0143, r24	; 0x800143 <nrf24_in_rx>
	}

	/* Tx mode */
	nrf24_write_reg(CONFIG, CONFIG_VAL | (1 << PWR_UP));
 414:	6e e7       	ldi	r22, 0x7E	; 126
 416:	80 e0       	ldi	r24, 0x00	; 0
 418:	0e 94 ac 03 	call	0x758	; 0x758 <nrf24_write_reg>
	/* Use pipe 0 for receiving ACK packets */
	nrf24_write_reg(EN_RXADDR, 0x01);
 41c:	61 e0       	ldi	r22, 0x01	; 1
 41e:	82 e0       	ldi	r24, 0x02	; 2
 420:	0e 94 ac 03 	call	0x758	; 0x758 <nrf24_write_reg>
	 * gets retransmitted about 3 times (sometimes 2, sometimes 4)
	 * instead of the chip picking up what we've written.  After that
	 * it picks up whatever the new payload is and again stops accepting
	 * new payloads for another while.
	 */
	nrf24_tx_flush();
 424:	0e 94 20 04 	call	0x840	; 0x840 <nrf24_tx_flush>

static inline void nrf24_csn(uint8_t level) {
	if (level)
		CSN_PORT |= CSN_PIN;
	else
		CSN_PORT &= ~CSN_PIN;
 428:	85 b1       	in	r24, 0x05	; 5
 42a:	8b 7f       	andi	r24, 0xFB	; 251
 42c:	85 b9       	out	0x05, r24	; 5
	 */
	nrf24_tx_flush();

	nrf24_csn(0);

	spi_transfer(W_TX_PAYLOAD);
 42e:	80 ea       	ldi	r24, 0xA0	; 160
 430:	0e 94 fe 03 	call	0x7fc	; 0x7fc <spi_transfer>
	while (len --)
 434:	0a c0       	rjmp	.+20     	; 0x44a <__DATA_REGION_LENGTH__+0x4a>
		spi_transfer(*buf ++);
 436:	78 01       	movw	r14, r16
 438:	8f ef       	ldi	r24, 0xFF	; 255
 43a:	e8 1a       	sub	r14, r24
 43c:	f8 0a       	sbc	r15, r24
 43e:	f8 01       	movw	r30, r16
 440:	80 81       	ld	r24, Z
 442:	0e 94 fe 03 	call	0x7fc	; 0x7fc <spi_transfer>
	nrf24_tx_flush();

	nrf24_csn(0);

	spi_transfer(W_TX_PAYLOAD);
	while (len --)
 446:	cd 2f       	mov	r28, r29
		spi_transfer(*buf ++);
 448:	87 01       	movw	r16, r14
	nrf24_tx_flush();

	nrf24_csn(0);

	spi_transfer(W_TX_PAYLOAD);
	while (len --)
 44a:	df ef       	ldi	r29, 0xFF	; 255
 44c:	dc 0f       	add	r29, r28
 44e:	c1 11       	cpse	r28, r1
 450:	f2 cf       	rjmp	.-28     	; 0x436 <__DATA_REGION_LENGTH__+0x36>
 */
#include "nRF24L01.h"

static inline void nrf24_csn(uint8_t level) {
	if (level)
		CSN_PORT |= CSN_PIN;
 452:	85 b1       	in	r24, 0x05	; 5
 454:	84 60       	ori	r24, 0x04	; 4
 456:	85 b9       	out	0x05, r24	; 5
	else
		while (timer_read() - prev_ce_edge <= F_CPU / 5000);
#else
	/* This should take at least 10us (rising) or 200us (falling) */
	if (level)
		my_delay(10);
 458:	8a e0       	ldi	r24, 0x0A	; 10
 45a:	90 e0       	ldi	r25, 0x00	; 0
 45c:	0e 94 9c 03 	call	0x738	; 0x738 <delay8>
	else
		my_delay(200);
#endif

	if (level)
		CE_PORT |= CE_PIN;
 460:	85 b1       	in	r24, 0x05	; 5
 462:	82 60       	ori	r24, 0x02	; 2
 464:	85 b9       	out	0x05, r24	; 5
	/*
	 * Set CE high for at least 10us - that's 160 cycles at 16MHz.
	 * But we can also leave it that way until tx_result_wait().
	 */
	nrf24_ce(1);
}
 466:	df 91       	pop	r29
 468:	cf 91       	pop	r28
 46a:	1f 91       	pop	r17
 46c:	0f 91       	pop	r16
 46e:	ff 90       	pop	r15
 470:	ef 90       	pop	r14
 472:	08 95       	ret

Disassembly of section .text.nrf24_tx_result_wait:

0000056a <nrf24_tx_result_wait>:

static int nrf24_tx_result_wait(void) {
 56a:	0f 93       	push	r16
 56c:	1f 93       	push	r17
 56e:	cf 93       	push	r28
 570:	df 93       	push	r29
	uint8_t status;
	uint16_t count = 10000; /* ~100ms timeout */

	status = nrf24_read_status();
 572:	0e 94 16 04 	call	0x82c	; 0x82c <nrf24_read_status>
 576:	c8 2f       	mov	r28, r24
#else
	/* This should take at least 10us (rising) or 200us (falling) */
	if (level)
		my_delay(10);
	else
		my_delay(200);
 578:	88 ec       	ldi	r24, 0xC8	; 200
 57a:	90 e0       	ldi	r25, 0x00	; 0
 57c:	0e 94 9c 03 	call	0x738	; 0x738 <delay8>
#endif

	if (level)
		CE_PORT |= CE_PIN;
	else
		CE_PORT &= ~CE_PIN;
 580:	85 b1       	in	r24, 0x05	; 5
 582:	8d 7f       	andi	r24, 0xFD	; 253
 584:	85 b9       	out	0x05, r24	; 5
	nrf24_ce(1);
}

static int nrf24_tx_result_wait(void) {
	uint8_t status;
	uint16_t count = 10000; /* ~100ms timeout */
 586:	00 e1       	ldi	r16, 0x10	; 16
 588:	17 e2       	ldi	r17, 0x27	; 39
 58a:	07 c0       	rjmp	.+14     	; 0x59a <nrf24_tx_result_wait+0x30>
	/* Reset CE early so that a new Tx or Rx op can start sooner. */
	nrf24_ce(0);

	while ((!(status & (1 << TX_DS)) || (status & (1 << TX_FULL))) &&
			!(status & (1 << MAX_RT)) && --count) {
		delay8((int) (F_CPU / 8000L * 0.01));
 58c:	8a e0       	ldi	r24, 0x0A	; 10
 58e:	90 e0       	ldi	r25, 0x00	; 0
 590:	0e 94 9c 03 	call	0x738	; 0x738 <delay8>
		status = nrf24_read_status();
 594:	0e 94 16 04 	call	0x82c	; 0x82c <nrf24_read_status>
 598:	c8 2f       	mov	r28, r24
	status = nrf24_read_status();

	/* Reset CE early so that a new Tx or Rx op can start sooner. */
	nrf24_ce(0);

	while ((!(status & (1 << TX_DS)) || (status & (1 << TX_FULL))) &&
 59a:	dc 2f       	mov	r29, r28
 59c:	d0 72       	andi	r29, 0x20	; 32
 59e:	c5 ff       	sbrs	r28, 5
 5a0:	02 c0       	rjmp	.+4      	; 0x5a6 <nrf24_tx_result_wait+0x3c>
 5a2:	c0 ff       	sbrs	r28, 0
 5a4:	05 c0       	rjmp	.+10     	; 0x5b0 <nrf24_tx_result_wait+0x46>
 5a6:	c4 fd       	sbrc	r28, 4
 5a8:	03 c0       	rjmp	.+6      	; 0x5b0 <nrf24_tx_result_wait+0x46>
			!(status & (1 << MAX_RT)) && --count) {
 5aa:	01 50       	subi	r16, 0x01	; 1
 5ac:	11 09       	sbc	r17, r1
 5ae:	71 f7       	brne	.-36     	; 0x58c <nrf24_tx_result_wait+0x22>
		delay8((int) (F_CPU / 8000L * 0.01));
		status = nrf24_read_status();
	}

	/* Reset status bits */
	nrf24_write_reg(STATUS, (1 << MAX_RT) | (1 << TX_DS));
 5b0:	60 e3       	ldi	r22, 0x30	; 48
 5b2:	87 e0       	ldi	r24, 0x07	; 7
 5b4:	0e 94 ac 03 	call	0x758	; 0x758 <nrf24_write_reg>

	if (nrf24_in_rx) {
 5b8:	80 91 43 01 	lds	r24, 0x0143	; 0x800143 <nrf24_in_rx>
 5bc:	88 23       	and	r24, r24
 5be:	21 f0       	breq	.+8      	; 0x5c8 <nrf24_tx_result_wait+0x5e>
		nrf24_in_rx = 0;
 5c0:	10 92 43 01 	sts	0x0143, r1	; 0x800143 <nrf24_in_rx>

		nrf24_rx_mode();
 5c4:	0e 94 86 03 	call	0x70c	; 0x70c <nrf24_rx_mode>
	}

	return (status & (1 << TX_DS)) ? 0 : -1;
 5c8:	dd 23       	and	r29, r29
 5ca:	19 f0       	breq	.+6      	; 0x5d2 <nrf24_tx_result_wait+0x68>
 5cc:	80 e0       	ldi	r24, 0x00	; 0
 5ce:	90 e0       	ldi	r25, 0x00	; 0
 5d0:	02 c0       	rjmp	.+4      	; 0x5d6 <nrf24_tx_result_wait+0x6c>
 5d2:	8f ef       	ldi	r24, 0xFF	; 255
 5d4:	9f ef       	ldi	r25, 0xFF	; 255
}
 5d6:	df 91       	pop	r29
 5d8:	cf 91       	pop	r28
 5da:	1f 91       	pop	r17
 5dc:	0f 91       	pop	r16
 5de:	08 95       	ret

Disassembly of section .text.radio_init:

00000474 <radio_init>:
#include "spi.h"
#include "nrf24.h"

//#define SEQN

static void radio_init(void) {
 474:	cf 93       	push	r28
 476:	df 93       	push	r29
 478:	00 d0       	rcall	.+0      	; 0x47a <radio_init+0x6>
 47a:	1f 92       	push	r1
 47c:	cd b7       	in	r28, 0x3d	; 61
 47e:	de b7       	in	r29, 0x3e	; 62
  uint8_t addr[3];

  spi_init();
 480:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <spi_init>

  if (nrf24_init())
 484:	0e 94 78 02 	call	0x4f0	; 0x4f0 <nrf24_init>
 488:	89 2b       	or	r24, r25
 48a:	61 f5       	brne	.+88     	; 0x4e4 <radio_init+0x70>
    return;

  radio_present = 1;
 48c:	81 e0       	ldi	r24, 0x01	; 1
 48e:	80 93 45 01 	sts	0x0145, r24	; 0x800145 <radio_present>
   * of the first packet we receive from the master.
   */
  /*
  Since addresses defined by me, have a first value between 0x20 - 0x40 exclusive
  */
   addr[0] = eeprom_read(0);
 492:	80 e0       	ldi	r24, 0x00	; 0
 494:	90 e0       	ldi	r25, 0x00	; 0
 496:	0e 94 34 04 	call	0x868	; 0x868 <eeprom_read>
 49a:	89 83       	std	Y+1, r24	; 0x01
	if(addr[0] > 0x40||addr[0] < 0x20){
 49c:	80 52       	subi	r24, 0x20	; 32
 49e:	81 32       	cpi	r24, 0x21	; 33
 4a0:	88 f0       	brcs	.+34     	; 0x4c4 <radio_init+0x50>
	   eeprom_write_byte(0,0x30);
 4a2:	60 e3       	ldi	r22, 0x30	; 48
 4a4:	80 e0       	ldi	r24, 0x00	; 0
 4a6:	90 e0       	ldi	r25, 0x00	; 0
 4a8:	0e 94 ca 03 	call	0x794	; 0x794 <eeprom_write_byte>
	   eeprom_write_byte(1,0x30);
 4ac:	60 e3       	ldi	r22, 0x30	; 48
 4ae:	81 e0       	ldi	r24, 0x01	; 1
 4b0:	90 e0       	ldi	r25, 0x00	; 0
 4b2:	0e 94 ca 03 	call	0x794	; 0x794 <eeprom_write_byte>
	   eeprom_write_byte(2,0x31);
 4b6:	61 e3       	ldi	r22, 0x31	; 49
 4b8:	82 e0       	ldi	r24, 0x02	; 2
 4ba:	90 e0       	ldi	r25, 0x00	; 0
 4bc:	0e 94 ca 03 	call	0x794	; 0x794 <eeprom_write_byte>
	   addr[0] = 0x30;
 4c0:	80 e3       	ldi	r24, 0x30	; 48
 4c2:	89 83       	std	Y+1, r24	; 0x01
	}
   addr[1] = eeprom_read(1);
 4c4:	81 e0       	ldi	r24, 0x01	; 1
 4c6:	90 e0       	ldi	r25, 0x00	; 0
 4c8:	0e 94 34 04 	call	0x868	; 0x868 <eeprom_read>
 4cc:	8a 83       	std	Y+2, r24	; 0x02
   addr[2] = eeprom_read(2);
 4ce:	82 e0       	ldi	r24, 0x02	; 2
 4d0:	90 e0       	ldi	r25, 0x00	; 0
 4d2:	0e 94 34 04 	call	0x868	; 0x868 <eeprom_read>
 4d6:	8b 83       	std	Y+3, r24	; 0x03
  nrf24_set_rx_addr(addr);
 4d8:	ce 01       	movw	r24, r28
 4da:	01 96       	adiw	r24, 0x01	; 1
 4dc:	0e 94 67 04 	call	0x8ce	; 0x8ce <nrf24_set_rx_addr>

  nrf24_rx_mode();
 4e0:	0e 94 86 03 	call	0x70c	; 0x70c <nrf24_rx_mode>
}
 4e4:	0f 90       	pop	r0
 4e6:	0f 90       	pop	r0
 4e8:	0f 90       	pop	r0
 4ea:	df 91       	pop	r29
 4ec:	cf 91       	pop	r28
 4ee:	08 95       	ret

Disassembly of section .text.putch:

00000642 <putch>:
#endif

void putch(char ch) {
#ifdef RADIO_UART
  if (radio_mode) {
 642:	90 91 46 01 	lds	r25, 0x0146	; 0x800146 <radio_mode>
 646:	99 23       	and	r25, r25
 648:	f9 f0       	breq	.+62     	; 0x688 <putch+0x46>
    static uint8_t pkt_len = 0;
    static uint8_t pkt_buf[32];

    pkt_buf[pkt_len++] = ch;
 64a:	e0 91 42 01 	lds	r30, 0x0142	; 0x800142 <pkt_len.1981>
 64e:	91 e0       	ldi	r25, 0x01	; 1
 650:	9e 0f       	add	r25, r30
 652:	90 93 42 01 	sts	0x0142, r25	; 0x800142 <pkt_len.1981>
 656:	f0 e0       	ldi	r31, 0x00	; 0
 658:	e0 5e       	subi	r30, 0xE0	; 224
 65a:	fe 4f       	sbci	r31, 0xFE	; 254
 65c:	80 83       	st	Z, r24

    if (ch == STK_OK || pkt_len == pkt_max_len) {
 65e:	80 31       	cpi	r24, 0x10	; 16
 660:	21 f0       	breq	.+8      	; 0x66a <putch+0x28>
 662:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <pkt_max_len>
 666:	98 13       	cpse	r25, r24
 668:	15 c0       	rjmp	.+42     	; 0x694 <putch+0x52>

      pkt_len = 1;
      pkt_buf[0] ++;
#else
      /* Wait 4ms to allow the remote end to switch to Rx mode */
      my_delay(4000);
 66a:	80 ea       	ldi	r24, 0xA0	; 160
 66c:	9f e0       	ldi	r25, 0x0F	; 15
 66e:	0e 94 9c 03 	call	0x738	; 0x738 <delay8>

      nrf24_tx(pkt_buf, pkt_len);
 672:	60 91 42 01 	lds	r22, 0x0142	; 0x800142 <pkt_len.1981>
 676:	80 e2       	ldi	r24, 0x20	; 32
 678:	91 e0       	ldi	r25, 0x01	; 1
 67a:	0e 94 f8 01 	call	0x3f0	; 0x3f0 <nrf24_tx>
      nrf24_tx_result_wait();
 67e:	0e 94 b5 02 	call	0x56a	; 0x56a <nrf24_tx_result_wait>

      pkt_len = 0;
 682:	10 92 42 01 	sts	0x0142, r1	; 0x800142 <pkt_len.1981>
 686:	08 95       	ret

    return;
  }
#endif
#ifndef SOFT_UART
  while (!(UART_SRA & _BV(UDRE0)));
 688:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fc0c0>
 68c:	95 ff       	sbrs	r25, 5
 68e:	fc cf       	rjmp	.-8      	; 0x688 <putch+0x46>
  UART_UDR = ch;
 690:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fc0c6>
 694:	08 95       	ret

Disassembly of section .text.getch:

00000350 <getch>:
      break;
    }
#endif

#ifdef RADIO_UART
    if (radio_present && (pkt_len || nrf24_rx_fifo_data())) {
 350:	80 91 45 01 	lds	r24, 0x0145	; 0x800145 <radio_present>
 354:	88 23       	and	r24, r24
 356:	e1 f3       	breq	.-8      	; 0x350 <getch>
 358:	80 91 41 01 	lds	r24, 0x0141	; 0x800141 <pkt_len.1990>
 35c:	81 11       	cpse	r24, r1
 35e:	04 c0       	rjmp	.+8      	; 0x368 <getch+0x18>
 360:	0e 94 4e 04 	call	0x89c	; 0x89c <nrf24_rx_fifo_data>
 364:	88 23       	and	r24, r24
 366:	a1 f3       	breq	.-24     	; 0x350 <getch>
}
#endif

// Watchdog functions. These are only safe with interrupts turned off.
void watchdogReset() {
  __asm__ __volatile__ (
 368:	a8 95       	wdr

#ifdef RADIO_UART
    if (radio_present && (pkt_len || nrf24_rx_fifo_data())) {
      watchdogReset();

      if (!pkt_len) {
 36a:	80 91 41 01 	lds	r24, 0x0141	; 0x800141 <pkt_len.1990>
 36e:	81 11       	cpse	r24, r1
 370:	2f c0       	rjmp	.+94     	; 0x3d0 <getch+0x80>
        static uint8_t seqn = 0xff;
#define START 1
#else
#define START 0
#endif
        nrf24_rx_read(pkt_buf, &pkt_len);
 372:	61 e4       	ldi	r22, 0x41	; 65
 374:	71 e0       	ldi	r23, 0x01	; 1
 376:	80 e0       	ldi	r24, 0x00	; 0
 378:	91 e0       	ldi	r25, 0x01	; 1
 37a:	0e 94 f0 02 	call	0x5e0	; 0x5e0 <nrf24_rx_read>
        pkt_start = START;
 37e:	10 92 40 01 	sts	0x0140, r1	; 0x800140 <pkt_start.1991>

        if (!radio_mode && pkt_len >= 4) {
 382:	80 91 46 01 	lds	r24, 0x0146	; 0x800146 <radio_mode>
 386:	81 11       	cpse	r24, r1
 388:	1a c0       	rjmp	.+52     	; 0x3be <getch+0x6e>
 38a:	90 91 41 01 	lds	r25, 0x0141	; 0x800141 <pkt_len.1990>
 38e:	94 30       	cpi	r25, 0x04	; 4
 390:	b0 f0       	brcs	.+44     	; 0x3be <getch+0x6e>
          /*
           * If this is the first packet we receive, the first three bytes
           * should contain the sender's address.
           */
          nrf24_set_tx_addr(pkt_buf);
 392:	80 e0       	ldi	r24, 0x00	; 0
 394:	91 e0       	ldi	r25, 0x01	; 1
 396:	0e 94 bc 03 	call	0x778	; 0x778 <nrf24_set_tx_addr>
          pkt_max_len = pkt_buf[3];
 39a:	80 91 03 01 	lds	r24, 0x0103	; 0x800103 <__DATA_REGION_ORIGIN__+0x3>
 39e:	80 93 44 01 	sts	0x0144, r24	; 0x800144 <pkt_max_len>
          pkt_len -= 4;
 3a2:	80 91 41 01 	lds	r24, 0x0141	; 0x800141 <pkt_len.1990>
 3a6:	84 50       	subi	r24, 0x04	; 4
 3a8:	80 93 41 01 	sts	0x0141, r24	; 0x800141 <pkt_len.1990>
          pkt_start += 4;
 3ac:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <pkt_start.1991>
 3b0:	8c 5f       	subi	r24, 0xFC	; 252
 3b2:	80 93 40 01 	sts	0x0140, r24	; 0x800140 <pkt_start.1991>

          radio_mode = 1;
 3b6:	81 e0       	ldi	r24, 0x01	; 1
 3b8:	80 93 46 01 	sts	0x0146, r24	; 0x800146 <radio_mode>
 3bc:	04 c0       	rjmp	.+8      	; 0x3c6 <getch+0x76>
        } else if (!radio_mode)
 3be:	81 11       	cpse	r24, r1
 3c0:	02 c0       	rjmp	.+4      	; 0x3c6 <getch+0x76>
          pkt_len = 0;
 3c2:	10 92 41 01 	sts	0x0141, r1	; 0x800141 <pkt_len.1990>

        if (!pkt_len)
 3c6:	80 91 41 01 	lds	r24, 0x0141	; 0x800141 <pkt_len.1990>
 3ca:	88 23       	and	r24, r24
 3cc:	09 f4       	brne	.+2      	; 0x3d0 <getch+0x80>
 3ce:	c0 cf       	rjmp	.-128    	; 0x350 <getch>
        seqn = pkt_buf[0];
        pkt_len--;
#endif
      }

      ch = pkt_buf[pkt_start ++];
 3d0:	e0 91 40 01 	lds	r30, 0x0140	; 0x800140 <pkt_start.1991>
 3d4:	81 e0       	ldi	r24, 0x01	; 1
 3d6:	8e 0f       	add	r24, r30
 3d8:	80 93 40 01 	sts	0x0140, r24	; 0x800140 <pkt_start.1991>
 3dc:	f0 e0       	ldi	r31, 0x00	; 0
 3de:	e0 50       	subi	r30, 0x00	; 0
 3e0:	ff 4f       	sbci	r31, 0xFF	; 255
 3e2:	80 81       	ld	r24, Z
      pkt_len --;
 3e4:	90 91 41 01 	lds	r25, 0x0141	; 0x800141 <pkt_len.1990>
 3e8:	91 50       	subi	r25, 0x01	; 1
 3ea:	90 93 41 01 	sts	0x0141, r25	; 0x800141 <pkt_len.1990>
  LED_PIN |= _BV(LED);
#endif
#endif

  return ch;
}
 3ee:	08 95       	ret

Disassembly of section .text.watchdogConfig:

000008b8 <watchdogConfig>:
    "wdr\n"
  );
}

void watchdogConfig(uint8_t x) {
  WDTCSR = _BV(WDCE) | _BV(WDE);
 8b8:	e0 e6       	ldi	r30, 0x60	; 96
 8ba:	f0 e0       	ldi	r31, 0x00	; 0
 8bc:	98 e1       	ldi	r25, 0x18	; 24
 8be:	90 83       	st	Z, r25
  WDTCSR = x;
 8c0:	80 83       	st	Z, r24
 8c2:	08 95       	ret

Disassembly of section .text.wait_timeout:

000008aa <wait_timeout>:
  verifySpace();
}

void wait_timeout(void) {
#ifdef RADIO_UART
  nrf24_idle_mode(0);		      // power the radio off
 8aa:	80 e0       	ldi	r24, 0x00	; 0
 8ac:	0e 94 4b 03 	call	0x696	; 0x696 <nrf24_idle_mode>
#endif
  watchdogConfig(WATCHDOG_16MS);      // shorten WD timeout
 8b0:	88 e0       	ldi	r24, 0x08	; 8
 8b2:	0e 94 5c 04 	call	0x8b8	; 0x8b8 <watchdogConfig>
 8b6:	ff cf       	rjmp	.-2      	; 0x8b6 <wait_timeout+0xc>

Disassembly of section .text.verifySpace:

00000854 <verifySpace>:
  while (1)			      // and busy-loop so that WD causes
    ;				      //  a reset and app start.
}

void verifySpace(void) {
  if (getch() != CRC_EOP)
 854:	0e 94 a8 01 	call	0x350	; 0x350 <__data_load_end>
 858:	80 32       	cpi	r24, 0x20	; 32
 85a:	11 f0       	breq	.+4      	; 0x860 <verifySpace+0xc>
    wait_timeout();
 85c:	0e 94 55 04 	call	0x8aa	; 0x8aa <wait_timeout>
  putch(STK_INSYNC);
 860:	84 e1       	ldi	r24, 0x14	; 20
 862:	0e 94 21 03 	call	0x642	; 0x642 <putch>
 866:	08 95       	ret

Disassembly of section .text.appStart:

0000088c <appStart>:
void watchdogConfig(uint8_t x) {
  WDTCSR = _BV(WDCE) | _BV(WDE);
  WDTCSR = x;
}

void appStart(uint8_t rstFlags) {
 88c:	c8 2f       	mov	r28, r24
#ifdef FORCE_WATCHDOG
  watchdogConfig(WATCHDOG_4S);
#else
  watchdogConfig(WATCHDOG_OFF);
 88e:	80 e0       	ldi	r24, 0x00	; 0
 890:	0e 94 5c 04 	call	0x8b8	; 0x8b8 <watchdogConfig>
#endif

  // save the reset flags in the designated register
  //  This can be saved in a main program by putting code in .init0 (which
  //  executes before normal c init code) to save R2 to a global variable.
  __asm__ __volatile__ ("mov r2, %0\n" :: "r" (rstFlags));
 894:	2c 2e       	mov	r2, r28

  __asm__ __volatile__ (
 896:	ee 27       	eor	r30, r30
 898:	ff 27       	eor	r31, r31
 89a:	09 94       	ijmp

Disassembly of section .text.avrlibc:

00000794 <eeprom_write_byte>:
 794:	26 2f       	mov	r18, r22

00000796 <eeprom_write_r18>:
 796:	f9 99       	sbic	0x1f, 1	; 31
 798:	fe cf       	rjmp	.-4      	; 0x796 <eeprom_write_r18>
 79a:	1f ba       	out	0x1f, r1	; 31
 79c:	92 bd       	out	0x22, r25	; 34
 79e:	81 bd       	out	0x21, r24	; 33
 7a0:	20 bd       	out	0x20, r18	; 32
 7a2:	0f b6       	in	r0, 0x3f	; 63
 7a4:	f8 94       	cli
 7a6:	fa 9a       	sbi	0x1f, 2	; 31
 7a8:	f9 9a       	sbi	0x1f, 1	; 31
 7aa:	0f be       	out	0x3f, r0	; 63
 7ac:	01 96       	adiw	r24, 0x01	; 1
 7ae:	08 95       	ret
