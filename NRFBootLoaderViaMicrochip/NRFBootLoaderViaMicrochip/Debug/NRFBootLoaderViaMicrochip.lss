
NRFBootLoaderViaMicrochip.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  00000a1e  2**0
                  ALLOC, LOAD, DATA
  1 .text         0000035c  00000000  00000000  000000f4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .comment      0000002f  00000000  00000000  00000a1e  2**0
                  CONTENTS, READONLY
  3 .version      00000002  00000000  00000000  00000a4d  2**0
                  CONTENTS, READONLY
  4 .stack.descriptors.hdr 0000000e  00000000  00000000  00000a4f  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 00000128  00000000  00000000  00000a60  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001ccd  00000000  00000000  00000b88  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000088e  00000000  00000000  00002855  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000ccb  00000000  00000000  000030e3  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000288  00000000  00000000  00003db0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000227  00000000  00000000  00004038  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000bcd  00000000  00000000  0000425f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000128  00000000  00000000  00004e2c  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .text         00000004  00000924  00000924  00000a18  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 14 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004f54  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .text.eeprom_write 00000018  00000830  00000830  00000924  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 16 .text.eeprom_read 00000012  000008b4  000008b4  000009a8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 17 .text.spi_mode 00000012  000008c6  000008c6  000009ba  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 18 .text.spi_init 0000001a  000007fc  000007fc  000008f0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 19 .text.spi_transfer 00000018  00000848  00000848  0000093c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 20 .text.delay8  00000020  00000784  00000784  00000878  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 21 .text.nrf24_read_reg 00000018  00000860  00000860  00000954  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 22 .text.nrf24_write_reg 00000020  000007a4  000007a4  00000898  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 23 .text.nrf24_read_status 00000014  00000878  00000878  0000096c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 24 .text.nrf24_write_addr_reg 00000030  00000728  00000728  0000081c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 25 .text.nrf24_tx_flush 00000014  0000088c  0000088c  00000980  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 26 .text.nrf24_delay 0000000a  00000910  00000910  00000a04  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 27 .text.nrf24_init 0000007a  0000051a  0000051a  0000060e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 28 .text.nrf24_set_rx_addr 0000000a  0000091a  0000091a  00000a0e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 29 .text.nrf24_set_tx_addr 0000001c  000007c4  000007c4  000008b8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 30 .text.nrf24_rx_mode 0000002c  00000758  00000758  0000084c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 31 .text.nrf24_idle_mode 00000046  000006e2  000006e2  000007d6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 32 .text.nrf24_rx_fifo_data 0000000e  000008e8  000008e8  000009dc  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 33 .text.nrf24_rx_data_avail 0000001a  00000816  00000816  0000090a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 34 .text.nrf24_rx_read 00000062  00000680  00000680  00000774  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 35 .text.nrf24_tx 00000084  0000041a  0000041a  0000050e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 36 .text.nrf24_tx_result_wait 00000076  00000594  00000594  00000688  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 37 .text.radio_init 0000007c  0000049e  0000049e  00000592  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 38 .text.putch   00000076  0000060a  0000060a  000006fe  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 39 .text.getch   000000be  0000035c  0000035c  00000450  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 40 .text.watchdogConfig 0000000c  00000904  00000904  000009f8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 41 .text.wait_timeout 0000000e  000008f6  000008f6  000009ea  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 42 .text.verifySpace 00000014  000008a0  000008a0  00000994  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 43 .text.appStart 00000010  000008d8  000008d8  000009cc  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 44 .data.seqn.1997 00000001  00800140  00000928  00000a1c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 45 .bss.pkt_start.1995 00000001  00800141  00800141  00000a1e  2**0
                  ALLOC
 46 .bss.pkt_buf.1996 00000020  00800100  00800100  00000a1e  2**0
                  ALLOC
 47 .bss.pkt_len.1994 00000001  00800142  00800142  00000a1e  2**0
                  ALLOC
 48 .bss.pkt_buf.1982 00000020  00800120  00800120  00000a1e  2**0
                  ALLOC
 49 .bss.pkt_len.1981 00000001  00800143  00800143  00000a1e  2**0
                  ALLOC
 50 .bss.nrf24_in_rx 00000001  00800144  00800144  00000a1e  2**0
                  ALLOC
 51 .data.pkt_max_len 00000001  00800145  00000929  00000a1d  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 52 .bss.radio_present 00000001  00800146  00800146  00000a1e  2**0
                  ALLOC
 53 .bss.radio_mode 00000001  00800147  00800147  00000a1e  2**0
                  ALLOC
 54 .text.avrlibc 0000001c  000007e0  000007e0  000008d4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 43 00 	jmp	0x86	; 0x86 <__ctors_end>
   4:	0c 94 92 04 	jmp	0x924	; 0x924 <__bad_interrupt>
   8:	0c 94 92 04 	jmp	0x924	; 0x924 <__bad_interrupt>
   c:	0c 94 92 04 	jmp	0x924	; 0x924 <__bad_interrupt>
  10:	0c 94 92 04 	jmp	0x924	; 0x924 <__bad_interrupt>
  14:	0c 94 92 04 	jmp	0x924	; 0x924 <__bad_interrupt>
  18:	0c 94 92 04 	jmp	0x924	; 0x924 <__bad_interrupt>
  1c:	0c 94 92 04 	jmp	0x924	; 0x924 <__bad_interrupt>
  20:	0c 94 92 04 	jmp	0x924	; 0x924 <__bad_interrupt>
  24:	0c 94 92 04 	jmp	0x924	; 0x924 <__bad_interrupt>
  28:	0c 94 92 04 	jmp	0x924	; 0x924 <__bad_interrupt>
  2c:	0c 94 92 04 	jmp	0x924	; 0x924 <__bad_interrupt>
  30:	0c 94 92 04 	jmp	0x924	; 0x924 <__bad_interrupt>
  34:	0c 94 92 04 	jmp	0x924	; 0x924 <__bad_interrupt>
  38:	0c 94 92 04 	jmp	0x924	; 0x924 <__bad_interrupt>
  3c:	0c 94 92 04 	jmp	0x924	; 0x924 <__bad_interrupt>
  40:	0c 94 92 04 	jmp	0x924	; 0x924 <__bad_interrupt>
  44:	0c 94 92 04 	jmp	0x924	; 0x924 <__bad_interrupt>
  48:	0c 94 92 04 	jmp	0x924	; 0x924 <__bad_interrupt>
  4c:	0c 94 92 04 	jmp	0x924	; 0x924 <__bad_interrupt>
  50:	0c 94 92 04 	jmp	0x924	; 0x924 <__bad_interrupt>
  54:	0c 94 92 04 	jmp	0x924	; 0x924 <__bad_interrupt>
  58:	0c 94 92 04 	jmp	0x924	; 0x924 <__bad_interrupt>
  5c:	0c 94 92 04 	jmp	0x924	; 0x924 <__bad_interrupt>
  60:	0c 94 92 04 	jmp	0x924	; 0x924 <__bad_interrupt>
  64:	0c 94 92 04 	jmp	0x924	; 0x924 <__bad_interrupt>

00000068 <.dinit>:
  68:	01 00       	.word	0x0001	; ????
  6a:	01 40       	sbci	r16, 0x01	; 1
  6c:	80 01       	movw	r16, r0
  6e:	40 01       	movw	r8, r0
  70:	41 00       	.word	0x0041	; ????
  72:	09 28       	or	r0, r9
  74:	01 41       	sbci	r16, 0x11	; 17
  76:	01 45       	sbci	r16, 0x51	; 81
  78:	80 01       	movw	r16, r0
  7a:	45 01       	movw	r8, r10
  7c:	46 00       	.word	0x0046	; ????
  7e:	09 29       	or	r16, r9
  80:	01 46       	sbci	r16, 0x61	; 97
  82:	01 48       	sbci	r16, 0x81	; 129
  84:	80 00       	.word	0x0080	; ????

00000086 <__ctors_end>:
  86:	11 24       	eor	r1, r1
  88:	1f be       	out	0x3f, r1	; 63
  8a:	cf ef       	ldi	r28, 0xFF	; 255
  8c:	d4 e0       	ldi	r29, 0x04	; 4
  8e:	de bf       	out	0x3e, r29	; 62
  90:	cd bf       	out	0x3d, r28	; 61

00000092 <__do_copy_data>:
  92:	e8 e6       	ldi	r30, 0x68	; 104
  94:	f0 e0       	ldi	r31, 0x00	; 0
  96:	40 e0       	ldi	r20, 0x00	; 0
  98:	17 c0       	rjmp	.+46     	; 0xc8 <__do_clear_bss+0x8>
  9a:	b5 91       	lpm	r27, Z+
  9c:	a5 91       	lpm	r26, Z+
  9e:	35 91       	lpm	r19, Z+
  a0:	25 91       	lpm	r18, Z+
  a2:	05 91       	lpm	r16, Z+
  a4:	07 fd       	sbrc	r16, 7
  a6:	0c c0       	rjmp	.+24     	; 0xc0 <__do_clear_bss>
  a8:	95 91       	lpm	r25, Z+
  aa:	85 91       	lpm	r24, Z+
  ac:	ef 01       	movw	r28, r30
  ae:	f9 2f       	mov	r31, r25
  b0:	e8 2f       	mov	r30, r24
  b2:	05 90       	lpm	r0, Z+
  b4:	0d 92       	st	X+, r0
  b6:	a2 17       	cp	r26, r18
  b8:	b3 07       	cpc	r27, r19
  ba:	d9 f7       	brne	.-10     	; 0xb2 <__do_copy_data+0x20>
  bc:	fe 01       	movw	r30, r28
  be:	04 c0       	rjmp	.+8      	; 0xc8 <__do_clear_bss+0x8>

000000c0 <__do_clear_bss>:
  c0:	1d 92       	st	X+, r1
  c2:	a2 17       	cp	r26, r18
  c4:	b3 07       	cpc	r27, r19
  c6:	e1 f7       	brne	.-8      	; 0xc0 <__do_clear_bss>
  c8:	e5 38       	cpi	r30, 0x85	; 133
  ca:	f4 07       	cpc	r31, r20
  cc:	31 f7       	brne	.-52     	; 0x9a <__do_copy_data+0x8>
  ce:	0e 94 6b 00 	call	0xd6	; 0xd6 <main>
  d2:	0c 94 ac 01 	jmp	0x358	; 0x358 <_exit>

000000d6 <main>:
  //  SP points to RAMEND
  //  r1 contains zero
  //
  // If not, uncomment the following instructions:
  // cli();
  asm volatile ("cli");
  d6:	f8 94       	cli
  asm volatile ("clr __zero_reg__");
  d8:	11 24       	eor	r1, r1
  /* Save the original reset reason to pass on to the applicatoin */
  reset_cause = ch;
  marker = 0xdeadbeef;
#else
  // Adaboot no-wait mod
  ch = MCUSR;
  da:	84 b7       	in	r24, 0x34	; 52
  MCUSR = 0;
  dc:	14 be       	out	0x34, r1	; 52
  if (ch & (_BV(WDRF) | _BV(PORF) | _BV(BORF)))
  de:	98 2f       	mov	r25, r24
  e0:	9d 70       	andi	r25, 0x0D	; 13
  e2:	11 f0       	breq	.+4      	; 0xe8 <main+0x12>
    appStart(ch);
  e4:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <appStart>
#endif

#if BSS_SIZE > 0
  // Prepare .data
  asm volatile (
  e8:	11 e0       	ldi	r17, 0x01	; 1
  ea:	a0 e0       	ldi	r26, 0x00	; 0
  ec:	b1 e0       	ldi	r27, 0x01	; 1
  ee:	ec e5       	ldi	r30, 0x5C	; 92
  f0:	f3 e0       	ldi	r31, 0x03	; 3
  f2:	02 c0       	rjmp	.+4      	; 0xf8 <cpchk>

000000f4 <copy>:
  f4:	05 90       	lpm	r0, Z+
  f6:	0d 92       	st	X+, r0

000000f8 <cpchk>:
  f8:	a0 30       	cpi	r26, 0x00	; 0
  fa:	b1 07       	cpc	r27, r17
  fc:	d9 f7       	brne	.-10     	; 0xf4 <copy>
	"	st	X+, __tmp_reg__\n"
	"cpchk:	cpi	r26, lo8(__data_end)\n"
	"	cpc	r27, r17\n"
	"	brne	copy\n");
  // Prepare .bss
  asm volatile (
  fe:	11 e0       	ldi	r17, 0x01	; 1
 100:	a0 e0       	ldi	r26, 0x00	; 0
 102:	b1 e0       	ldi	r27, 0x01	; 1
 104:	01 c0       	rjmp	.+2      	; 0x108 <clchk>

00000106 <clear>:
 106:	1d 92       	st	X+, r1

00000108 <clchk>:
 108:	a0 30       	cpi	r26, 0x00	; 0
 10a:	b1 07       	cpc	r27, r17
 10c:	e1 f7       	brne	.-8      	; 0x106 <clear>
  /*
   * Disable pullups that may have been enabled by a user program.
   * Somehow a pullup on RXD screws up everything unless RXD is externally
   * driven high.
   */
  DDRD |= 3;
 10e:	8a b1       	in	r24, 0x0a	; 10
 110:	83 60       	ori	r24, 0x03	; 3
 112:	8a b9       	out	0x0a, r24	; 10
  PORTD &= ~3;
 114:	8b b1       	in	r24, 0x0b	; 11
 116:	8c 7f       	andi	r24, 0xFC	; 252
 118:	8b b9       	out	0x0b, r24	; 11
  UCSRA = _BV(U2X); //Double speed mode USART
  UCSRB = _BV(RXEN) | _BV(TXEN);  // enable Rx & Tx
  UCSRC = _BV(URSEL) | _BV(UCSZ1) | _BV(UCSZ0);  // config USART; 8N1
  UBRRL = (uint8_t)( (F_CPU + BAUD_RATE * 4L) / (BAUD_RATE * 8L) - 1 );
#else
  UART_SRA = _BV(U2X0); //Double speed mode USART0
 11a:	82 e0       	ldi	r24, 0x02	; 2
 11c:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fc0c0>
  UART_SRB = _BV(RXEN0) | _BV(TXEN0);
 120:	88 e1       	ldi	r24, 0x18	; 24
 122:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7fc0c1>
  UART_SRC = _BV(UCSZ00) | _BV(UCSZ01);
 126:	86 e0       	ldi	r24, 0x06	; 6
 128:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7fc0c2>
  UART_SRL = (uint8_t)( (F_CPU + BAUD_RATE * 4L) / (BAUD_RATE * 8L) - 1 );
 12c:	88 e0       	ldi	r24, 0x08	; 8
 12e:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7fc0c4>
#endif
#endif
#ifdef RADIO_UART
  radio_init();
 132:	0e 94 4f 02 	call	0x49e	; 0x49e <radio_init>
#endif

  // Set up watchdog to trigger after 500ms
  watchdogConfig(WATCHDOG_1S);
 136:	8e e0       	ldi	r24, 0x0E	; 14
 138:	0e 94 82 04 	call	0x904	; 0x904 <watchdogConfig>
   * Making these local and in registers prevents the need for initializing
   * them, and also saves space because code no longer stores to memory.
   * (initializing address keeps the compiler happy, but isn't really
   *  necessary, and uses 4 bytes of flash.)
   */
  register uint16_t address = 0;
 13c:	00 e0       	ldi	r16, 0x00	; 0
 13e:	10 e0       	ldi	r17, 0x00	; 0
#endif

  /* Forever loop */
  for (;;) {
    /* get character from UART */
    ch = getch();
 140:	0e 94 ae 01 	call	0x35c	; 0x35c <_etext>

    if(ch == STK_GET_PARAMETER) {
 144:	81 34       	cpi	r24, 0x41	; 65
 146:	a9 f4       	brne	.+42     	; 0x172 <clchk+0x6a>
      unsigned char which = getch();
 148:	0e 94 ae 01 	call	0x35c	; 0x35c <_etext>
 14c:	c8 2f       	mov	r28, r24
      verifySpace();
 14e:	0e 94 50 04 	call	0x8a0	; 0x8a0 <verifySpace>
      if (which == 0x82) {
 152:	c2 38       	cpi	r28, 0x82	; 130
 154:	21 f4       	brne	.+8      	; 0x15e <clchk+0x56>
	/*
	 * Send optiboot version as "minor SW version"
	 */
	putch(OPTIBOOT_MINVER);
 156:	80 e0       	ldi	r24, 0x00	; 0
 158:	0e 94 05 03 	call	0x60a	; 0x60a <putch>
 15c:	f9 c0       	rjmp	.+498    	; 0x350 <__EEPROM_REGION_LENGTH__+0x150>
      } else if (which == 0x81) {
 15e:	c1 38       	cpi	r28, 0x81	; 129
 160:	21 f4       	brne	.+8      	; 0x16a <clchk+0x62>
	  putch(OPTIBOOT_MAJVER);
 162:	85 e0       	ldi	r24, 0x05	; 5
 164:	0e 94 05 03 	call	0x60a	; 0x60a <putch>
 168:	f3 c0       	rjmp	.+486    	; 0x350 <__EEPROM_REGION_LENGTH__+0x150>
      } else {
	/*
	 * GET PARAMETER returns a generic 0x03 reply for
         * other parameters - enough to keep Avrdude happy
	 */
	putch(0x03);
 16a:	83 e0       	ldi	r24, 0x03	; 3
 16c:	0e 94 05 03 	call	0x60a	; 0x60a <putch>
 170:	ef c0       	rjmp	.+478    	; 0x350 <__EEPROM_REGION_LENGTH__+0x150>
      }
    }
    else if(ch == STK_SET_DEVICE) {
 172:	82 34       	cpi	r24, 0x42	; 66
 174:	41 f4       	brne	.+16     	; 0x186 <clchk+0x7e>
 176:	c4 e1       	ldi	r28, 0x14	; 20
  );
}
#endif

void getNch(uint8_t count) {
  do getch(); while (--count);
 178:	0e 94 ae 01 	call	0x35c	; 0x35c <_etext>
 17c:	c1 50       	subi	r28, 0x01	; 1
 17e:	e1 f7       	brne	.-8      	; 0x178 <clchk+0x70>
  verifySpace();
 180:	0e 94 50 04 	call	0x8a0	; 0x8a0 <verifySpace>
 184:	e5 c0       	rjmp	.+458    	; 0x350 <__EEPROM_REGION_LENGTH__+0x150>
    }
    else if(ch == STK_SET_DEVICE) {
      // SET DEVICE is ignored
      getNch(20);
    }
    else if(ch == STK_SET_DEVICE_EXT) {
 186:	85 34       	cpi	r24, 0x45	; 69
 188:	41 f4       	brne	.+16     	; 0x19a <clchk+0x92>
 18a:	c5 e0       	ldi	r28, 0x05	; 5
  );
}
#endif

void getNch(uint8_t count) {
  do getch(); while (--count);
 18c:	0e 94 ae 01 	call	0x35c	; 0x35c <_etext>
 190:	c1 50       	subi	r28, 0x01	; 1
 192:	e1 f7       	brne	.-8      	; 0x18c <clchk+0x84>
  verifySpace();
 194:	0e 94 50 04 	call	0x8a0	; 0x8a0 <verifySpace>
 198:	db c0       	rjmp	.+438    	; 0x350 <__EEPROM_REGION_LENGTH__+0x150>
    }
    else if(ch == STK_SET_DEVICE_EXT) {
      // SET DEVICE EXT is ignored
      getNch(5);
    }
    else if(ch == STK_LOAD_ADDRESS) {
 19a:	85 35       	cpi	r24, 0x55	; 85
 19c:	89 f4       	brne	.+34     	; 0x1c0 <clchk+0xb8>
      // LOAD ADDRESS
      uint16_t newAddress;
      newAddress = getch();
 19e:	0e 94 ae 01 	call	0x35c	; 0x35c <_etext>
 1a2:	c8 2f       	mov	r28, r24
 1a4:	d0 e0       	ldi	r29, 0x00	; 0
      newAddress |= getch() << 8;
 1a6:	0e 94 ae 01 	call	0x35c	; 0x35c <_etext>
 1aa:	08 2f       	mov	r16, r24
 1ac:	10 e0       	ldi	r17, 0x00	; 0
 1ae:	10 2f       	mov	r17, r16
 1b0:	00 27       	eor	r16, r16
 1b2:	0c 2b       	or	r16, r28
 1b4:	1d 2b       	or	r17, r29
#ifdef RAMPZ
      // Transfer top bit to RAMPZ
      RAMPZ = (newAddress & 0x8000) ? 1 : 0;
#endif
      newAddress <<= 1; // Convert from word address to byte address
 1b6:	00 0f       	add	r16, r16
 1b8:	11 1f       	adc	r17, r17
      address = newAddress;
      verifySpace();
 1ba:	0e 94 50 04 	call	0x8a0	; 0x8a0 <verifySpace>
 1be:	c8 c0       	rjmp	.+400    	; 0x350 <__EEPROM_REGION_LENGTH__+0x150>
    }
    else if(ch == STK_UNIVERSAL) {
 1c0:	86 35       	cpi	r24, 0x56	; 86
 1c2:	59 f4       	brne	.+22     	; 0x1da <clchk+0xd2>
 1c4:	c4 e0       	ldi	r28, 0x04	; 4
  );
}
#endif

void getNch(uint8_t count) {
  do getch(); while (--count);
 1c6:	0e 94 ae 01 	call	0x35c	; 0x35c <_etext>
 1ca:	c1 50       	subi	r28, 0x01	; 1
 1cc:	e1 f7       	brne	.-8      	; 0x1c6 <clchk+0xbe>
  verifySpace();
 1ce:	0e 94 50 04 	call	0x8a0	; 0x8a0 <verifySpace>
      verifySpace();
    }
    else if(ch == STK_UNIVERSAL) {
      // UNIVERSAL command is ignored
      getNch(4);
      putch(0x00);
 1d2:	80 e0       	ldi	r24, 0x00	; 0
 1d4:	0e 94 05 03 	call	0x60a	; 0x60a <putch>
 1d8:	bb c0       	rjmp	.+374    	; 0x350 <__EEPROM_REGION_LENGTH__+0x150>
    }
    /* Write memory, length is big endian and is in bytes */
    else if(ch == STK_PROG_PAGE) {
 1da:	84 36       	cpi	r24, 0x64	; 100
 1dc:	09 f0       	breq	.+2      	; 0x1e0 <clchk+0xd8>
 1de:	77 c0       	rjmp	.+238    	; 0x2ce <__EEPROM_REGION_LENGTH__+0xce>
      // PROGRAM PAGE - we support flash and EEPROM programming
      uint8_t *bufPtr;
      uint16_t addrPtr;
      uint8_t type;

      getch();			/* getlen() */
 1e0:	0e 94 ae 01 	call	0x35c	; 0x35c <_etext>
      length = getch();
 1e4:	0e 94 ae 01 	call	0x35c	; 0x35c <_etext>
 1e8:	f8 2e       	mov	r15, r24
      type = getch();
 1ea:	0e 94 ae 01 	call	0x35c	; 0x35c <_etext>
 1ee:	e8 2e       	mov	r14, r24

#ifdef SUPPORT_EEPROM
      if (type == 'F')		/* Flash */
 1f0:	86 e4       	ldi	r24, 0x46	; 70
 1f2:	e8 12       	cpse	r14, r24
 1f4:	0b c0       	rjmp	.+22     	; 0x20c <__EEPROM_REGION_LENGTH__+0xc>
#endif
        // If we are in RWW section, immediately start page erase
        if (address < NRWWSTART) __boot_page_erase_short((uint16_t)(void*)address);
 1f6:	01 15       	cp	r16, r1
 1f8:	e8 e3       	ldi	r30, 0x38	; 56
 1fa:	1e 07       	cpc	r17, r30
 1fc:	50 f4       	brcc	.+20     	; 0x212 <__EEPROM_REGION_LENGTH__+0x12>
 1fe:	83 e0       	ldi	r24, 0x03	; 3
 200:	f8 01       	movw	r30, r16
 202:	87 bf       	out	0x37, r24	; 55
 204:	e8 95       	spm
 206:	c0 e8       	ldi	r28, 0x80	; 128
 208:	d1 e0       	ldi	r29, 0x01	; 1
 20a:	05 c0       	rjmp	.+10     	; 0x216 <__EEPROM_REGION_LENGTH__+0x16>
 20c:	c0 e8       	ldi	r28, 0x80	; 128
 20e:	d1 e0       	ldi	r29, 0x01	; 1
 210:	02 c0       	rjmp	.+4      	; 0x216 <__EEPROM_REGION_LENGTH__+0x16>
 212:	c0 e8       	ldi	r28, 0x80	; 128
 214:	d1 e0       	ldi	r29, 0x01	; 1

      // While that is going on, read in page contents
      bufPtr = buff;
      do *bufPtr++ = getch();
 216:	6e 01       	movw	r12, r28
 218:	ff ef       	ldi	r31, 0xFF	; 255
 21a:	cf 1a       	sub	r12, r31
 21c:	df 0a       	sbc	r13, r31
 21e:	0e 94 ae 01 	call	0x35c	; 0x35c <_etext>
 222:	88 83       	st	Y, r24
      while (--length);
 224:	fa 94       	dec	r15
        // If we are in RWW section, immediately start page erase
        if (address < NRWWSTART) __boot_page_erase_short((uint16_t)(void*)address);

      // While that is going on, read in page contents
      bufPtr = buff;
      do *bufPtr++ = getch();
 226:	e6 01       	movw	r28, r12
      while (--length);
 228:	f1 10       	cpse	r15, r1
 22a:	f5 cf       	rjmp	.-22     	; 0x216 <__EEPROM_REGION_LENGTH__+0x16>

#ifdef SUPPORT_EEPROM
      if (type == 'F') {	/* Flash */
 22c:	86 e4       	ldi	r24, 0x46	; 70
 22e:	e8 12       	cpse	r14, r24
 230:	2f c0       	rjmp	.+94     	; 0x290 <__EEPROM_REGION_LENGTH__+0x90>
#endif
        // If we are in NRWW section, page erase has to be delayed until now.
        // Todo: Take RAMPZ into account (not doing so just means that we will
        //  treat the top of both "pages" of flash as NRWW, for a slight speed
        //  decrease, so fixing this is not urgent.)
        if (address >= NRWWSTART) __boot_page_erase_short((uint16_t)(void*)address);
 232:	01 15       	cp	r16, r1
 234:	e8 e3       	ldi	r30, 0x38	; 56
 236:	1e 07       	cpc	r17, r30
 238:	20 f0       	brcs	.+8      	; 0x242 <__EEPROM_REGION_LENGTH__+0x42>
 23a:	83 e0       	ldi	r24, 0x03	; 3
 23c:	f8 01       	movw	r30, r16
 23e:	87 bf       	out	0x37, r24	; 55
 240:	e8 95       	spm

        // Read command terminator, start reply
        verifySpace();
 242:	0e 94 50 04 	call	0x8a0	; 0x8a0 <verifySpace>

        // If only a partial page is to be programmed, the erase might not be complete.
        // So check that here
        boot_spm_busy_wait();
 246:	07 b6       	in	r0, 0x37	; 55
 248:	00 fc       	sbrc	r0, 0
 24a:	fd cf       	rjmp	.-6      	; 0x246 <__EEPROM_REGION_LENGTH__+0x46>
 24c:	f8 01       	movw	r30, r16
 24e:	a0 e8       	ldi	r26, 0x80	; 128
 250:	b1 e0       	ldi	r27, 0x01	; 1
 252:	20 e4       	ldi	r18, 0x40	; 64
        bufPtr = buff;
        addrPtr = (uint16_t)(void*)address;
        ch = SPM_PAGESIZE / 2;
        do {
          uint16_t a;
          a = *bufPtr++;
 254:	3c 91       	ld	r19, X
          a |= (*bufPtr++) << 8;
 256:	ad 01       	movw	r20, r26
 258:	4e 5f       	subi	r20, 0xFE	; 254
 25a:	5f 4f       	sbci	r21, 0xFF	; 255
 25c:	11 96       	adiw	r26, 0x01	; 1
 25e:	8c 91       	ld	r24, X
 260:	90 e0       	ldi	r25, 0x00	; 0
 262:	98 2f       	mov	r25, r24
 264:	88 27       	eor	r24, r24
 266:	83 2b       	or	r24, r19
          __boot_page_fill_short((uint16_t)(void*)addrPtr,a);
 268:	31 e0       	ldi	r19, 0x01	; 1
 26a:	0c 01       	movw	r0, r24
 26c:	37 bf       	out	0x37, r19	; 55
 26e:	e8 95       	spm
 270:	11 24       	eor	r1, r1
          addrPtr += 2;
 272:	32 96       	adiw	r30, 0x02	; 2
        } while (--ch);
 274:	21 50       	subi	r18, 0x01	; 1
        addrPtr = (uint16_t)(void*)address;
        ch = SPM_PAGESIZE / 2;
        do {
          uint16_t a;
          a = *bufPtr++;
          a |= (*bufPtr++) << 8;
 276:	da 01       	movw	r26, r20
          __boot_page_fill_short((uint16_t)(void*)addrPtr,a);
          addrPtr += 2;
        } while (--ch);
 278:	69 f7       	brne	.-38     	; 0x254 <__EEPROM_REGION_LENGTH__+0x54>

        // Write from programming buffer
        __boot_page_write_short((uint16_t)(void*)address);
 27a:	85 e0       	ldi	r24, 0x05	; 5
 27c:	f8 01       	movw	r30, r16
 27e:	87 bf       	out	0x37, r24	; 55
 280:	e8 95       	spm
        boot_spm_busy_wait();
 282:	07 b6       	in	r0, 0x37	; 55
 284:	00 fc       	sbrc	r0, 0
 286:	fd cf       	rjmp	.-6      	; 0x282 <__EEPROM_REGION_LENGTH__+0x82>

#if defined(RWWSRE)
        // Reenable read access to flash
        boot_rww_enable();
 288:	81 e1       	ldi	r24, 0x11	; 17
 28a:	87 bf       	out	0x37, r24	; 55
 28c:	e8 95       	spm
 28e:	60 c0       	rjmp	.+192    	; 0x350 <__EEPROM_REGION_LENGTH__+0x150>
#endif
#ifdef SUPPORT_EEPROM
      } else if (type == 'E') {	/* EEPROM */
 290:	f5 e4       	ldi	r31, 0x45	; 69
 292:	ef 12       	cpse	r14, r31
 294:	5d c0       	rjmp	.+186    	; 0x350 <__EEPROM_REGION_LENGTH__+0x150>
        // Read command terminator, start reply
        verifySpace();
 296:	0e 94 50 04 	call	0x8a0	; 0x8a0 <verifySpace>

        length = bufPtr - buff;
 29a:	90 e8       	ldi	r25, 0x80	; 128
 29c:	9c 0d       	add	r25, r12
        addrPtr = address;
 29e:	98 01       	movw	r18, r16
        bufPtr = buff;
 2a0:	e0 e8       	ldi	r30, 0x80	; 128
 2a2:	f1 e0       	ldi	r31, 0x01	; 1
        while (length--) {
 2a4:	0e c0       	rjmp	.+28     	; 0x2c2 <__EEPROM_REGION_LENGTH__+0xc2>
}
#endif

// Watchdog functions. These are only safe with interrupts turned off.
void watchdogReset() {
  __asm__ __volatile__ (
 2a6:	a8 95       	wdr
        length = bufPtr - buff;
        addrPtr = address;
        bufPtr = buff;
        while (length--) {
          watchdogReset();
          eeprom_write(addrPtr++, *bufPtr++);
 2a8:	ef 01       	movw	r28, r30
 2aa:	21 96       	adiw	r28, 0x01	; 1
 2ac:	79 01       	movw	r14, r18
 2ae:	8f ef       	ldi	r24, 0xFF	; 255
 2b0:	e8 1a       	sub	r14, r24
 2b2:	f8 0a       	sbc	r15, r24
 2b4:	60 81       	ld	r22, Z
 2b6:	c9 01       	movw	r24, r18
 2b8:	0e 94 18 04 	call	0x830	; 0x830 <eeprom_write>
        verifySpace();

        length = bufPtr - buff;
        addrPtr = address;
        bufPtr = buff;
        while (length--) {
 2bc:	9d 2d       	mov	r25, r13
          watchdogReset();
          eeprom_write(addrPtr++, *bufPtr++);
 2be:	97 01       	movw	r18, r14
 2c0:	fe 01       	movw	r30, r28
        verifySpace();

        length = bufPtr - buff;
        addrPtr = address;
        bufPtr = buff;
        while (length--) {
 2c2:	dd 24       	eor	r13, r13
 2c4:	da 94       	dec	r13
 2c6:	d9 0e       	add	r13, r25
 2c8:	91 11       	cpse	r25, r1
 2ca:	ed cf       	rjmp	.-38     	; 0x2a6 <__EEPROM_REGION_LENGTH__+0xa6>
 2cc:	41 c0       	rjmp	.+130    	; 0x350 <__EEPROM_REGION_LENGTH__+0x150>
        }
      }
#endif
    }
    /* Read memory block mode, length is big endian.  */
    else if(ch == STK_READ_PAGE) {
 2ce:	84 37       	cpi	r24, 0x74	; 116
 2d0:	39 f5       	brne	.+78     	; 0x320 <__EEPROM_REGION_LENGTH__+0x120>
      // READ PAGE - we only read flash and EEPROM
      uint8_t type;

      getch();			/* getlen() */
 2d2:	0e 94 ae 01 	call	0x35c	; 0x35c <_etext>
      length = getch();
 2d6:	0e 94 ae 01 	call	0x35c	; 0x35c <_etext>
 2da:	c8 2f       	mov	r28, r24
      type = getch();
 2dc:	0e 94 ae 01 	call	0x35c	; 0x35c <_etext>
 2e0:	d8 2f       	mov	r29, r24

      verifySpace();
 2e2:	0e 94 50 04 	call	0x8a0	; 0x8a0 <verifySpace>
      /* TODO: putNch */
#ifdef SUPPORT_EEPROM
      if (type == 'F')
 2e6:	d6 34       	cpi	r29, 0x46	; 70
 2e8:	41 f4       	brne	.+16     	; 0x2fa <__EEPROM_REGION_LENGTH__+0xfa>
          //      while (--length);
          // read a Flash and increment the address (may increment RAMPZ)
          __asm__ ("elpm %0,Z+\n" : "=r" (ch), "=z" (address): "1" (address));
#else
          // read a Flash byte and increment the address
          __asm__ ("lpm %0,Z+\n" : "=r" (ch), "=z" (address): "1" (address));
 2ea:	f8 01       	movw	r30, r16
 2ec:	85 91       	lpm	r24, Z+
 2ee:	8f 01       	movw	r16, r30
#endif
          putch(ch);
 2f0:	0e 94 05 03 	call	0x60a	; 0x60a <putch>
        } while (--length);
 2f4:	c1 50       	subi	r28, 0x01	; 1
 2f6:	c9 f7       	brne	.-14     	; 0x2ea <__EEPROM_REGION_LENGTH__+0xea>
 2f8:	2b c0       	rjmp	.+86     	; 0x350 <__EEPROM_REGION_LENGTH__+0x150>
#ifdef SUPPORT_EEPROM
      else if (type == 'E')
 2fa:	d5 34       	cpi	r29, 0x45	; 69
 2fc:	49 f5       	brne	.+82     	; 0x350 <__EEPROM_REGION_LENGTH__+0x150>
 2fe:	0b c0       	rjmp	.+22     	; 0x316 <__EEPROM_REGION_LENGTH__+0x116>
        while (length--)
          putch(eeprom_read(address++));
 300:	78 01       	movw	r14, r16
 302:	ef ef       	ldi	r30, 0xFF	; 255
 304:	ee 1a       	sub	r14, r30
 306:	fe 0a       	sbc	r15, r30
 308:	c8 01       	movw	r24, r16
 30a:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <eeprom_read>
 30e:	0e 94 05 03 	call	0x60a	; 0x60a <putch>
#endif
          putch(ch);
        } while (--length);
#ifdef SUPPORT_EEPROM
      else if (type == 'E')
        while (length--)
 312:	cd 2f       	mov	r28, r29
          putch(eeprom_read(address++));
 314:	87 01       	movw	r16, r14
#endif
          putch(ch);
        } while (--length);
#ifdef SUPPORT_EEPROM
      else if (type == 'E')
        while (length--)
 316:	df ef       	ldi	r29, 0xFF	; 255
 318:	dc 0f       	add	r29, r28
 31a:	c1 11       	cpse	r28, r1
 31c:	f1 cf       	rjmp	.-30     	; 0x300 <__EEPROM_REGION_LENGTH__+0x100>
 31e:	18 c0       	rjmp	.+48     	; 0x350 <__EEPROM_REGION_LENGTH__+0x150>
          putch(eeprom_read(address++));
#endif
    }

    /* Get device signature bytes  */
    else if(ch == STK_READ_SIGN) {
 320:	85 37       	cpi	r24, 0x75	; 117
 322:	61 f4       	brne	.+24     	; 0x33c <__EEPROM_REGION_LENGTH__+0x13c>
      // READ SIGN - return what Avrdude wants to hear
      verifySpace();
 324:	0e 94 50 04 	call	0x8a0	; 0x8a0 <verifySpace>
      putch(SIGNATURE_0);
 328:	8e e1       	ldi	r24, 0x1E	; 30
 32a:	0e 94 05 03 	call	0x60a	; 0x60a <putch>
      putch(SIGNATURE_1);
 32e:	84 e9       	ldi	r24, 0x94	; 148
 330:	0e 94 05 03 	call	0x60a	; 0x60a <putch>
      putch(SIGNATURE_2);
 334:	86 e0       	ldi	r24, 0x06	; 6
 336:	0e 94 05 03 	call	0x60a	; 0x60a <putch>
 33a:	0a c0       	rjmp	.+20     	; 0x350 <__EEPROM_REGION_LENGTH__+0x150>
    }
    else if (ch == STK_LEAVE_PROGMODE) { /* 'Q' */
 33c:	81 35       	cpi	r24, 0x51	; 81
 33e:	31 f4       	brne	.+12     	; 0x34c <__EEPROM_REGION_LENGTH__+0x14c>
      // Adaboot no-wait mod
      watchdogConfig(WATCHDOG_16MS);
 340:	88 e0       	ldi	r24, 0x08	; 8
 342:	0e 94 82 04 	call	0x904	; 0x904 <watchdogConfig>
      verifySpace();
 346:	0e 94 50 04 	call	0x8a0	; 0x8a0 <verifySpace>
 34a:	02 c0       	rjmp	.+4      	; 0x350 <__EEPROM_REGION_LENGTH__+0x150>
    }
    else {
      // This covers the response to commands like STK_ENTER_PROGMODE
      verifySpace();
 34c:	0e 94 50 04 	call	0x8a0	; 0x8a0 <verifySpace>
    }
    putch(STK_OK);
 350:	80 e1       	ldi	r24, 0x10	; 16
 352:	0e 94 05 03 	call	0x60a	; 0x60a <putch>
  }
 356:	f4 ce       	rjmp	.-536    	; 0x140 <clchk+0x38>

00000358 <_exit>:
 358:	f8 94       	cli

0000035a <__stop_program>:
 35a:	ff cf       	rjmp	.-2      	; 0x35a <__stop_program>

Disassembly of section .text:

00000924 <__bad_interrupt>:
 924:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

Disassembly of section .text.eeprom_write:

00000830 <eeprom_write>:
# define UART_SRL UBRR3L
# define UART_UDR UDR3
#endif

static void eeprom_write(uint16_t addr, uint8_t val) {
  while (!eeprom_is_ready());
 830:	f9 99       	sbic	0x1f, 1	; 31
 832:	fe cf       	rjmp	.-4      	; 0x830 <eeprom_write>

  EEAR = addr;
 834:	92 bd       	out	0x22, r25	; 34
 836:	81 bd       	out	0x21, r24	; 33
  EEDR = val;
 838:	60 bd       	out	0x20, r22	; 32
  EECR |= 1 << EEMPE;	/* Write logical one to EEMPE */
 83a:	8f b3       	in	r24, 0x1f	; 31
 83c:	84 60       	ori	r24, 0x04	; 4
 83e:	8f bb       	out	0x1f, r24	; 31
  EECR |= 1 << EEPE;	/* Start eeprom write by setting EEPE */
 840:	8f b3       	in	r24, 0x1f	; 31
 842:	82 60       	ori	r24, 0x02	; 2
 844:	8f bb       	out	0x1f, r24	; 31
 846:	08 95       	ret

Disassembly of section .text.eeprom_read:

000008b4 <eeprom_read>:
}

static uint8_t eeprom_read(uint16_t addr) {
  while (!eeprom_is_ready());
 8b4:	f9 99       	sbic	0x1f, 1	; 31
 8b6:	fe cf       	rjmp	.-4      	; 0x8b4 <eeprom_read>

  EEAR = addr;
 8b8:	92 bd       	out	0x22, r25	; 34
 8ba:	81 bd       	out	0x21, r24	; 33
  EECR |= 1 << EERE;	/* Start eeprom read by writing EERE */
 8bc:	8f b3       	in	r24, 0x1f	; 31
 8be:	81 60       	ori	r24, 0x01	; 1
 8c0:	8f bb       	out	0x1f, r24	; 31

  return EEDR;
 8c2:	80 b5       	in	r24, 0x20	; 32
}
 8c4:	08 95       	ret

Disassembly of section .text.spi_mode:

000008c6 <spi_mode>:
#define MOSI_PIN	(1 << 3)
#define SS_PIN		(1 << 2)

static void spi_mode(uint8_t mode) {
	/* Enable SPI master with configuration byte specified */
	SPCR = 0;
 8c6:	1c bc       	out	0x2c, r1	; 44
	SPCR = (mode & 0x7F) | (1 << SPE) | (1 << MSTR);
 8c8:	8f 72       	andi	r24, 0x2F	; 47
 8ca:	80 65       	ori	r24, 0x50	; 80
 8cc:	8c bd       	out	0x2c, r24	; 44
	SPSR = 1 << SPI2X; /* double speed */
 8ce:	81 e0       	ldi	r24, 0x01	; 1
 8d0:	8d bd       	out	0x2d, r24	; 45
	(void) SPSR;
 8d2:	8d b5       	in	r24, 0x2d	; 45
	(void) SPDR;
 8d4:	8e b5       	in	r24, 0x2e	; 46
 8d6:	08 95       	ret

Disassembly of section .text.spi_init:

000007fc <spi_init>:
}

static void spi_init(void) {
	/* Initialize the SPI pins: SCK & MOSI as outputs, MISO as input */
	SPI_DDR |= SCK_PIN | MOSI_PIN;
 7fc:	84 b1       	in	r24, 0x04	; 4
 7fe:	88 62       	ori	r24, 0x28	; 40
 800:	84 b9       	out	0x04, r24	; 4
	SPI_DDR &= ~MISO_PIN;
 802:	84 b1       	in	r24, 0x04	; 4
 804:	8f 7e       	andi	r24, 0xEF	; 239
 806:	84 b9       	out	0x04, r24	; 4
	/* Must also pre-set SS to output, otherwise it's going to bite us */
	SPI_DDR |= SS_PIN;
 808:	84 b1       	in	r24, 0x04	; 4
 80a:	84 60       	ori	r24, 0x04	; 4
 80c:	84 b9       	out	0x04, r24	; 4

	/* Enable SPI Master, MSB, SPI mode 0, FOSC/4 */
	spi_mode(0);
 80e:	80 e0       	ldi	r24, 0x00	; 0
 810:	0e 94 63 04 	call	0x8c6	; 0x8c6 <spi_mode>
 814:	08 95       	ret

Disassembly of section .text.spi_transfer:

00000848 <spi_transfer>:
}

static uint8_t spi_transfer(uint8_t value) {
	uint8_t cnt = 0xff;
	SPDR = value;
 848:	8e bd       	out	0x2e, r24	; 46
	/* Enable SPI Master, MSB, SPI mode 0, FOSC/4 */
	spi_mode(0);
}

static uint8_t spi_transfer(uint8_t value) {
	uint8_t cnt = 0xff;
 84a:	8f ef       	ldi	r24, 0xFF	; 255
	SPDR = value;
	while (cnt -- && !(SPSR & (1 << SPIF)));
 84c:	9f ef       	ldi	r25, 0xFF	; 255
 84e:	98 0f       	add	r25, r24
 850:	88 23       	and	r24, r24
 852:	21 f0       	breq	.+8      	; 0x85c <spi_transfer+0x14>
 854:	89 2f       	mov	r24, r25
 856:	0d b4       	in	r0, 0x2d	; 45
 858:	07 fe       	sbrs	r0, 7
 85a:	f8 cf       	rjmp	.-16     	; 0x84c <spi_transfer+0x4>
	return SPDR;
 85c:	8e b5       	in	r24, 0x2e	; 46
}
 85e:	08 95       	ret

Disassembly of section .text.delay8:

00000784 <delay8>:
	else
		CSN_PORT &= ~CSN_PIN;
}

static void delay8(uint16_t count) {
	while (count --)
 784:	09 c0       	rjmp	.+18     	; 0x798 <delay8+0x14>
	...
		__asm__ __volatile__ (
 792:	00 00       	nop
 794:	a8 95       	wdr
	else
		CSN_PORT &= ~CSN_PIN;
}

static void delay8(uint16_t count) {
	while (count --)
 796:	c9 01       	movw	r24, r18
 798:	9c 01       	movw	r18, r24
 79a:	21 50       	subi	r18, 0x01	; 1
 79c:	31 09       	sbc	r19, r1
 79e:	89 2b       	or	r24, r25
 7a0:	91 f7       	brne	.-28     	; 0x786 <delay8+0x2>
			"\tnop\n"
			"\tnop\n"
			"\tnop\n"
			"\twdr\n"
		);
}
 7a2:	08 95       	ret

Disassembly of section .text.nrf24_read_reg:

00000860 <nrf24_read_reg>:

static inline void nrf24_csn(uint8_t level) {
	if (level)
		CSN_PORT |= CSN_PIN;
	else
		CSN_PORT &= ~CSN_PIN;
 860:	95 b1       	in	r25, 0x05	; 5
 862:	9b 7f       	andi	r25, 0xFB	; 251
 864:	95 b9       	out	0x05, r25	; 5
static uint8_t nrf24_read_reg(uint8_t addr) {
	uint8_t ret;

	nrf24_csn(0);

	spi_transfer(addr | R_REGISTER);
 866:	0e 94 24 04 	call	0x848	; 0x848 <spi_transfer>
	ret = spi_transfer(0);
 86a:	80 e0       	ldi	r24, 0x00	; 0
 86c:	0e 94 24 04 	call	0x848	; 0x848 <spi_transfer>
 */
#include "nRF24L01.h"

static inline void nrf24_csn(uint8_t level) {
	if (level)
		CSN_PORT |= CSN_PIN;
 870:	95 b1       	in	r25, 0x05	; 5
 872:	94 60       	ori	r25, 0x04	; 4
 874:	95 b9       	out	0x05, r25	; 5
	ret = spi_transfer(0);

	nrf24_csn(1);

	return ret;
}
 876:	08 95       	ret

Disassembly of section .text.nrf24_write_reg:

000007a4 <nrf24_write_reg>:

static void nrf24_write_reg(uint8_t addr, uint8_t value) {
 7a4:	cf 93       	push	r28
 7a6:	c6 2f       	mov	r28, r22

static inline void nrf24_csn(uint8_t level) {
	if (level)
		CSN_PORT |= CSN_PIN;
	else
		CSN_PORT &= ~CSN_PIN;
 7a8:	95 b1       	in	r25, 0x05	; 5
 7aa:	9b 7f       	andi	r25, 0xFB	; 251
 7ac:	95 b9       	out	0x05, r25	; 5
}

static void nrf24_write_reg(uint8_t addr, uint8_t value) {
	nrf24_csn(0);

	spi_transfer(addr | W_REGISTER);
 7ae:	80 62       	ori	r24, 0x20	; 32
 7b0:	0e 94 24 04 	call	0x848	; 0x848 <spi_transfer>
	spi_transfer(value);
 7b4:	8c 2f       	mov	r24, r28
 7b6:	0e 94 24 04 	call	0x848	; 0x848 <spi_transfer>
 */
#include "nRF24L01.h"

static inline void nrf24_csn(uint8_t level) {
	if (level)
		CSN_PORT |= CSN_PIN;
 7ba:	85 b1       	in	r24, 0x05	; 5
 7bc:	84 60       	ori	r24, 0x04	; 4
 7be:	85 b9       	out	0x05, r24	; 5

	spi_transfer(addr | W_REGISTER);
	spi_transfer(value);

	nrf24_csn(1);
}
 7c0:	cf 91       	pop	r28
 7c2:	08 95       	ret

Disassembly of section .text.nrf24_read_status:

00000878 <nrf24_read_status>:

static inline void nrf24_csn(uint8_t level) {
	if (level)
		CSN_PORT |= CSN_PIN;
	else
		CSN_PORT &= ~CSN_PIN;
 878:	85 b1       	in	r24, 0x05	; 5
 87a:	8b 7f       	andi	r24, 0xFB	; 251
 87c:	85 b9       	out	0x05, r24	; 5
static uint8_t nrf24_read_status(void) {
	uint8_t ret;

	nrf24_csn(0);

	ret = spi_transfer(NOP);
 87e:	8f ef       	ldi	r24, 0xFF	; 255
 880:	0e 94 24 04 	call	0x848	; 0x848 <spi_transfer>
 */
#include "nRF24L01.h"

static inline void nrf24_csn(uint8_t level) {
	if (level)
		CSN_PORT |= CSN_PIN;
 884:	95 b1       	in	r25, 0x05	; 5
 886:	94 60       	ori	r25, 0x04	; 4
 888:	95 b9       	out	0x05, r25	; 5
	ret = spi_transfer(NOP);

	nrf24_csn(1);

	return ret;
}
 88a:	08 95       	ret

Disassembly of section .text.nrf24_write_addr_reg:

00000728 <nrf24_write_addr_reg>:

static void nrf24_write_addr_reg(uint8_t addr, uint8_t value[3]) {
 728:	cf 93       	push	r28
 72a:	df 93       	push	r29
 72c:	eb 01       	movw	r28, r22

static inline void nrf24_csn(uint8_t level) {
	if (level)
		CSN_PORT |= CSN_PIN;
	else
		CSN_PORT &= ~CSN_PIN;
 72e:	95 b1       	in	r25, 0x05	; 5
 730:	9b 7f       	andi	r25, 0xFB	; 251
 732:	95 b9       	out	0x05, r25	; 5
}

static void nrf24_write_addr_reg(uint8_t addr, uint8_t value[3]) {
	nrf24_csn(0);

	spi_transfer(addr | W_REGISTER);
 734:	80 62       	ori	r24, 0x20	; 32
 736:	0e 94 24 04 	call	0x848	; 0x848 <spi_transfer>
	spi_transfer(value[0]);
 73a:	88 81       	ld	r24, Y
 73c:	0e 94 24 04 	call	0x848	; 0x848 <spi_transfer>
	spi_transfer(value[1]);
 740:	89 81       	ldd	r24, Y+1	; 0x01
 742:	0e 94 24 04 	call	0x848	; 0x848 <spi_transfer>
	spi_transfer(value[2]);
 746:	8a 81       	ldd	r24, Y+2	; 0x02
 748:	0e 94 24 04 	call	0x848	; 0x848 <spi_transfer>
 */
#include "nRF24L01.h"

static inline void nrf24_csn(uint8_t level) {
	if (level)
		CSN_PORT |= CSN_PIN;
 74c:	85 b1       	in	r24, 0x05	; 5
 74e:	84 60       	ori	r24, 0x04	; 4
 750:	85 b9       	out	0x05, r24	; 5
	spi_transfer(value[0]);
	spi_transfer(value[1]);
	spi_transfer(value[2]);

	nrf24_csn(1);
}
 752:	df 91       	pop	r29
 754:	cf 91       	pop	r28
 756:	08 95       	ret

Disassembly of section .text.nrf24_tx_flush:

0000088c <nrf24_tx_flush>:

static inline void nrf24_csn(uint8_t level) {
	if (level)
		CSN_PORT |= CSN_PIN;
	else
		CSN_PORT &= ~CSN_PIN;
 88c:	85 b1       	in	r24, 0x05	; 5
 88e:	8b 7f       	andi	r24, 0xFB	; 251
 890:	85 b9       	out	0x05, r24	; 5
static uint8_t nrf24_tx_flush(void) {
	uint8_t ret;

	nrf24_csn(0);

	ret = spi_transfer(FLUSH_TX);
 892:	81 ee       	ldi	r24, 0xE1	; 225
 894:	0e 94 24 04 	call	0x848	; 0x848 <spi_transfer>
 */
#include "nRF24L01.h"

static inline void nrf24_csn(uint8_t level) {
	if (level)
		CSN_PORT |= CSN_PIN;
 898:	95 b1       	in	r25, 0x05	; 5
 89a:	94 60       	ori	r25, 0x04	; 4
 89c:	95 b9       	out	0x05, r25	; 5
	ret = spi_transfer(FLUSH_TX);

	nrf24_csn(1);

	return ret;
}
 89e:	08 95       	ret

Disassembly of section .text.nrf24_delay:

00000910 <nrf24_delay>:

static void nrf24_delay(void) {
	my_delay(5000);
 910:	88 e8       	ldi	r24, 0x88	; 136
 912:	93 e1       	ldi	r25, 0x13	; 19
 914:	0e 94 c2 03 	call	0x784	; 0x784 <delay8>
 918:	08 95       	ret

Disassembly of section .text.nrf24_init:

0000051a <nrf24_init>:
#define CONFIG_VAL ((1 << MASK_RX_DR) | (1 << MASK_TX_DS) | \
		(1 << MASK_MAX_RT) | (1 << CRCO) | (1 << EN_CRC))

static int nrf24_init(void) {
	/* CE and CSN are outputs */
	CE_DDR |= CE_PIN;
 51a:	84 b1       	in	r24, 0x04	; 4
 51c:	82 60       	ori	r24, 0x02	; 2
 51e:	84 b9       	out	0x04, r24	; 4
	CSN_DDR |= CSN_PIN;
 520:	84 b1       	in	r24, 0x04	; 4
 522:	84 60       	ori	r24, 0x04	; 4
 524:	84 b9       	out	0x04, r24	; 4
#else
	/* This should take at least 10us (rising) or 200us (falling) */
	if (level)
		my_delay(10);
	else
		my_delay(200);
 526:	88 ec       	ldi	r24, 0xC8	; 200
 528:	90 e0       	ldi	r25, 0x00	; 0
 52a:	0e 94 c2 03 	call	0x784	; 0x784 <delay8>
#endif

	if (level)
		CE_PORT |= CE_PIN;
	else
		CE_PORT &= ~CE_PIN;
 52e:	85 b1       	in	r24, 0x05	; 5
 530:	8d 7f       	andi	r24, 0xFD	; 253
 532:	85 b9       	out	0x05, r24	; 5
 */
#include "nRF24L01.h"

static inline void nrf24_csn(uint8_t level) {
	if (level)
		CSN_PORT |= CSN_PIN;
 534:	85 b1       	in	r24, 0x05	; 5
 536:	84 60       	ori	r24, 0x04	; 4
 538:	85 b9       	out	0x05, r24	; 5
	CE_DDR |= CE_PIN;
	CSN_DDR |= CSN_PIN;

	nrf24_ce(0);
	nrf24_csn(1);
	nrf24_delay();
 53a:	0e 94 88 04 	call	0x910	; 0x910 <nrf24_delay>

	/* 2ms interval, 15 retries (16 total) */
	nrf24_write_reg(SETUP_RETR, 0x7f);
 53e:	6f e7       	ldi	r22, 0x7F	; 127
 540:	84 e0       	ldi	r24, 0x04	; 4
 542:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <nrf24_write_reg>
	if (nrf24_read_reg(SETUP_RETR) != 0x7f)
 546:	84 e0       	ldi	r24, 0x04	; 4
 548:	0e 94 30 04 	call	0x860	; 0x860 <nrf24_read_reg>
 54c:	8f 37       	cpi	r24, 0x7F	; 127
 54e:	f9 f4       	brne	.+62     	; 0x58e <nrf24_init+0x74>
		return 1; /* There may be no nRF24 connected */

	/* Maximum Tx power, 250kbps data rate */
	nrf24_write_reg(RF_SETUP, (1 << RF_PWR_LOW) | (1 << RF_PWR_HIGH) |
 550:	66 e2       	ldi	r22, 0x26	; 38
 552:	86 e0       	ldi	r24, 0x06	; 6
 554:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <nrf24_write_reg>
			(1 << RF_DR_LOW));
	/* Dynamic payload length for TX & RX (pipes 0 and 1) */
	nrf24_write_reg(DYNPD, 0x03);
 558:	63 e0       	ldi	r22, 0x03	; 3
 55a:	8c e1       	ldi	r24, 0x1C	; 28
 55c:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <nrf24_write_reg>
	nrf24_write_reg(FEATURE, 1 << EN_DPL);
 560:	64 e0       	ldi	r22, 0x04	; 4
 562:	8d e1       	ldi	r24, 0x1D	; 29
 564:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <nrf24_write_reg>
	/* Reset status bits */
	nrf24_write_reg(STATUS, (1 << RX_DR) | (1 << TX_DS) | (1 << MAX_RT));
 568:	60 e7       	ldi	r22, 0x70	; 112
 56a:	87 e0       	ldi	r24, 0x07	; 7
 56c:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <nrf24_write_reg>
	/* Set some RF channel number */
	nrf24_write_reg(RF_CH, 42);
 570:	6a e2       	ldi	r22, 0x2A	; 42
 572:	85 e0       	ldi	r24, 0x05	; 5
 574:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <nrf24_write_reg>
	/* 3-byte addresses */
	nrf24_write_reg(SETUP_AW, 0x01);
 578:	61 e0       	ldi	r22, 0x01	; 1
 57a:	83 e0       	ldi	r24, 0x03	; 3
 57c:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <nrf24_write_reg>
	/* Enable ACKing on both pipe 0 & 1 for TX & RX ACK support */
	nrf24_write_reg(EN_AA, 0x03);
 580:	63 e0       	ldi	r22, 0x03	; 3
 582:	81 e0       	ldi	r24, 0x01	; 1
 584:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <nrf24_write_reg>

	return 0;
 588:	80 e0       	ldi	r24, 0x00	; 0
 58a:	90 e0       	ldi	r25, 0x00	; 0
 58c:	08 95       	ret
	nrf24_delay();

	/* 2ms interval, 15 retries (16 total) */
	nrf24_write_reg(SETUP_RETR, 0x7f);
	if (nrf24_read_reg(SETUP_RETR) != 0x7f)
		return 1; /* There may be no nRF24 connected */
 58e:	81 e0       	ldi	r24, 0x01	; 1
 590:	90 e0       	ldi	r25, 0x00	; 0
	nrf24_write_reg(SETUP_AW, 0x01);
	/* Enable ACKing on both pipe 0 & 1 for TX & RX ACK support */
	nrf24_write_reg(EN_AA, 0x03);

	return 0;
}
 592:	08 95       	ret

Disassembly of section .text.nrf24_set_rx_addr:

0000091a <nrf24_set_rx_addr>:

static void nrf24_set_rx_addr(uint8_t addr[3]) {
	nrf24_write_addr_reg(RX_ADDR_P1, addr);
 91a:	bc 01       	movw	r22, r24
 91c:	8b e0       	ldi	r24, 0x0B	; 11
 91e:	0e 94 94 03 	call	0x728	; 0x728 <nrf24_write_addr_reg>
 922:	08 95       	ret

Disassembly of section .text.nrf24_set_tx_addr:

000007c4 <nrf24_set_tx_addr>:
}

static void nrf24_set_tx_addr(uint8_t addr[3]) {
 7c4:	cf 93       	push	r28
 7c6:	df 93       	push	r29
 7c8:	ec 01       	movw	r28, r24
	nrf24_write_addr_reg(TX_ADDR, addr);
 7ca:	bc 01       	movw	r22, r24
 7cc:	80 e1       	ldi	r24, 0x10	; 16
 7ce:	0e 94 94 03 	call	0x728	; 0x728 <nrf24_write_addr_reg>
	/* The pipe 0 address is the address we listen on for ACKs */
	nrf24_write_addr_reg(RX_ADDR_P0, addr);
 7d2:	be 01       	movw	r22, r28
 7d4:	8a e0       	ldi	r24, 0x0A	; 10
 7d6:	0e 94 94 03 	call	0x728	; 0x728 <nrf24_write_addr_reg>
}
 7da:	df 91       	pop	r29
 7dc:	cf 91       	pop	r28
 7de:	08 95       	ret

Disassembly of section .text.nrf24_rx_mode:

00000758 <nrf24_rx_mode>:

static uint8_t nrf24_in_rx = 0;

static void nrf24_rx_mode(void) {
	if (nrf24_in_rx)
 758:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <nrf24_in_rx>
 75c:	81 11       	cpse	r24, r1
 75e:	11 c0       	rjmp	.+34     	; 0x782 <nrf24_rx_mode+0x2a>
		return;

	/* Rx mode */
	nrf24_write_reg(CONFIG, CONFIG_VAL | (1 << PWR_UP) | (1 << PRIM_RX));
 760:	6f e7       	ldi	r22, 0x7F	; 127
 762:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <nrf24_write_reg>
	/* Only use data pipe 1 for receiving, pipe 0 is for TX ACKs */
	nrf24_write_reg(EN_RXADDR, 0x02);
 766:	62 e0       	ldi	r22, 0x02	; 2
 768:	82 e0       	ldi	r24, 0x02	; 2
 76a:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <nrf24_write_reg>
	else
		while (timer_read() - prev_ce_edge <= F_CPU / 5000);
#else
	/* This should take at least 10us (rising) or 200us (falling) */
	if (level)
		my_delay(10);
 76e:	8a e0       	ldi	r24, 0x0A	; 10
 770:	90 e0       	ldi	r25, 0x00	; 0
 772:	0e 94 c2 03 	call	0x784	; 0x784 <delay8>
	else
		my_delay(200);
#endif

	if (level)
		CE_PORT |= CE_PIN;
 776:	85 b1       	in	r24, 0x05	; 5
 778:	82 60       	ori	r24, 0x02	; 2
 77a:	85 b9       	out	0x05, r24	; 5
	/* Only use data pipe 1 for receiving, pipe 0 is for TX ACKs */
	nrf24_write_reg(EN_RXADDR, 0x02);

	nrf24_ce(1);

	nrf24_in_rx = 1;
 77c:	81 e0       	ldi	r24, 0x01	; 1
 77e:	80 93 44 01 	sts	0x0144, r24	; 0x800144 <nrf24_in_rx>
 782:	08 95       	ret

Disassembly of section .text.nrf24_idle_mode:

000006e2 <nrf24_idle_mode>:
/*
 * This switches out of Rx mode and leaves the chip in Standby if desired.
 * Otherwise the chip is powered off.  In Standby a new operation will
 * start faster but more current is consumed while waiting.
 */
static void nrf24_idle_mode(uint8_t standby) {
 6e2:	cf 93       	push	r28
 6e4:	c8 2f       	mov	r28, r24
	if (nrf24_in_rx) {
 6e6:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <nrf24_in_rx>
 6ea:	88 23       	and	r24, r24
 6ec:	71 f0       	breq	.+28     	; 0x70a <nrf24_idle_mode+0x28>
#else
	/* This should take at least 10us (rising) or 200us (falling) */
	if (level)
		my_delay(10);
	else
		my_delay(200);
 6ee:	88 ec       	ldi	r24, 0xC8	; 200
 6f0:	90 e0       	ldi	r25, 0x00	; 0
 6f2:	0e 94 c2 03 	call	0x784	; 0x784 <delay8>
#endif

	if (level)
		CE_PORT |= CE_PIN;
	else
		CE_PORT &= ~CE_PIN;
 6f6:	85 b1       	in	r24, 0x05	; 5
 6f8:	8d 7f       	andi	r24, 0xFD	; 253
 6fa:	85 b9       	out	0x05, r24	; 5
 */
static void nrf24_idle_mode(uint8_t standby) {
	if (nrf24_in_rx) {
		nrf24_ce(0);

		if (!standby)
 6fc:	c1 11       	cpse	r28, r1
 6fe:	10 c0       	rjmp	.+32     	; 0x720 <nrf24_idle_mode+0x3e>
			nrf24_write_reg(CONFIG, CONFIG_VAL);
 700:	6c e7       	ldi	r22, 0x7C	; 124
 702:	80 e0       	ldi	r24, 0x00	; 0
 704:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <nrf24_write_reg>
 708:	0b c0       	rjmp	.+22     	; 0x720 <nrf24_idle_mode+0x3e>
	} else {
		if (standby)
 70a:	cc 23       	and	r28, r28
 70c:	29 f0       	breq	.+10     	; 0x718 <nrf24_idle_mode+0x36>
			nrf24_write_reg(CONFIG, CONFIG_VAL | (1 << PWR_UP));
 70e:	6e e7       	ldi	r22, 0x7E	; 126
 710:	80 e0       	ldi	r24, 0x00	; 0
 712:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <nrf24_write_reg>
 716:	04 c0       	rjmp	.+8      	; 0x720 <nrf24_idle_mode+0x3e>
		else
			nrf24_write_reg(CONFIG, CONFIG_VAL);
 718:	6c e7       	ldi	r22, 0x7C	; 124
 71a:	80 e0       	ldi	r24, 0x00	; 0
 71c:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <nrf24_write_reg>
	}

	nrf24_in_rx = 0;
 720:	10 92 44 01 	sts	0x0144, r1	; 0x800144 <nrf24_in_rx>
}
 724:	cf 91       	pop	r28
 726:	08 95       	ret

Disassembly of section .text.nrf24_rx_fifo_data:

000008e8 <nrf24_rx_fifo_data>:
static uint8_t nrf24_rx_new_data(void) {
	return (nrf24_read_status() >> RX_DR) & 1;
}

static uint8_t nrf24_rx_fifo_data(void) {
	return !(nrf24_read_reg(FIFO_STATUS) & (1 << RX_EMPTY));
 8e8:	87 e1       	ldi	r24, 0x17	; 23
 8ea:	0e 94 30 04 	call	0x860	; 0x860 <nrf24_read_reg>
 8ee:	91 e0       	ldi	r25, 0x01	; 1
 8f0:	89 27       	eor	r24, r25
}
 8f2:	81 70       	andi	r24, 0x01	; 1
 8f4:	08 95       	ret

Disassembly of section .text.nrf24_rx_data_avail:

00000816 <nrf24_rx_data_avail>:

static inline void nrf24_csn(uint8_t level) {
	if (level)
		CSN_PORT |= CSN_PIN;
	else
		CSN_PORT &= ~CSN_PIN;
 816:	85 b1       	in	r24, 0x05	; 5
 818:	8b 7f       	andi	r24, 0xFB	; 251
 81a:	85 b9       	out	0x05, r24	; 5
static uint8_t nrf24_rx_data_avail(void) {
	uint8_t ret;

	nrf24_csn(0);

	spi_transfer(R_RX_PL_WID);
 81c:	80 e6       	ldi	r24, 0x60	; 96
 81e:	0e 94 24 04 	call	0x848	; 0x848 <spi_transfer>
	ret = spi_transfer(0);
 822:	80 e0       	ldi	r24, 0x00	; 0
 824:	0e 94 24 04 	call	0x848	; 0x848 <spi_transfer>
 */
#include "nRF24L01.h"

static inline void nrf24_csn(uint8_t level) {
	if (level)
		CSN_PORT |= CSN_PIN;
 828:	95 b1       	in	r25, 0x05	; 5
 82a:	94 60       	ori	r25, 0x04	; 4
 82c:	95 b9       	out	0x05, r25	; 5
	ret = spi_transfer(0);

	nrf24_csn(1);

	return ret;
}
 82e:	08 95       	ret

Disassembly of section .text.nrf24_rx_read:

00000680 <nrf24_rx_read>:

static void nrf24_rx_read(uint8_t *buf, uint8_t *pkt_len) {
 680:	ef 92       	push	r14
 682:	ff 92       	push	r15
 684:	0f 93       	push	r16
 686:	1f 93       	push	r17
 688:	cf 93       	push	r28
 68a:	df 93       	push	r29
 68c:	8c 01       	movw	r16, r24
 68e:	7b 01       	movw	r14, r22
	uint8_t len;

	nrf24_write_reg(STATUS, 1 << RX_DR);
 690:	60 e4       	ldi	r22, 0x40	; 64
 692:	87 e0       	ldi	r24, 0x07	; 7
 694:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <nrf24_write_reg>

	len = nrf24_rx_data_avail();
 698:	0e 94 0b 04 	call	0x816	; 0x816 <nrf24_rx_data_avail>
 69c:	c8 2f       	mov	r28, r24
	*pkt_len = len;
 69e:	f7 01       	movw	r30, r14
 6a0:	80 83       	st	Z, r24

static inline void nrf24_csn(uint8_t level) {
	if (level)
		CSN_PORT |= CSN_PIN;
	else
		CSN_PORT &= ~CSN_PIN;
 6a2:	85 b1       	in	r24, 0x05	; 5
 6a4:	8b 7f       	andi	r24, 0xFB	; 251
 6a6:	85 b9       	out	0x05, r24	; 5
	len = nrf24_rx_data_avail();
	*pkt_len = len;

	nrf24_csn(0);

	spi_transfer(R_RX_PAYLOAD);
 6a8:	81 e6       	ldi	r24, 0x61	; 97
 6aa:	0e 94 24 04 	call	0x848	; 0x848 <spi_transfer>
	while (len --)
 6ae:	0b c0       	rjmp	.+22     	; 0x6c6 <nrf24_rx_read+0x46>
		*buf ++ = spi_transfer(0);
 6b0:	78 01       	movw	r14, r16
 6b2:	ff ef       	ldi	r31, 0xFF	; 255
 6b4:	ef 1a       	sub	r14, r31
 6b6:	ff 0a       	sbc	r15, r31
 6b8:	80 e0       	ldi	r24, 0x00	; 0
 6ba:	0e 94 24 04 	call	0x848	; 0x848 <spi_transfer>
 6be:	f8 01       	movw	r30, r16
 6c0:	80 83       	st	Z, r24
	*pkt_len = len;

	nrf24_csn(0);

	spi_transfer(R_RX_PAYLOAD);
	while (len --)
 6c2:	cd 2f       	mov	r28, r29
		*buf ++ = spi_transfer(0);
 6c4:	87 01       	movw	r16, r14
	*pkt_len = len;

	nrf24_csn(0);

	spi_transfer(R_RX_PAYLOAD);
	while (len --)
 6c6:	df ef       	ldi	r29, 0xFF	; 255
 6c8:	dc 0f       	add	r29, r28
 6ca:	c1 11       	cpse	r28, r1
 6cc:	f1 cf       	rjmp	.-30     	; 0x6b0 <nrf24_rx_read+0x30>
 */
#include "nRF24L01.h"

static inline void nrf24_csn(uint8_t level) {
	if (level)
		CSN_PORT |= CSN_PIN;
 6ce:	85 b1       	in	r24, 0x05	; 5
 6d0:	84 60       	ori	r24, 0x04	; 4
 6d2:	85 b9       	out	0x05, r24	; 5
	spi_transfer(R_RX_PAYLOAD);
	while (len --)
		*buf ++ = spi_transfer(0);

	nrf24_csn(1);
}
 6d4:	df 91       	pop	r29
 6d6:	cf 91       	pop	r28
 6d8:	1f 91       	pop	r17
 6da:	0f 91       	pop	r16
 6dc:	ff 90       	pop	r15
 6de:	ef 90       	pop	r14
 6e0:	08 95       	ret

Disassembly of section .text.nrf24_tx:

0000041a <nrf24_tx>:

static void nrf24_tx(uint8_t *buf, uint8_t len) {
 41a:	ef 92       	push	r14
 41c:	ff 92       	push	r15
 41e:	0f 93       	push	r16
 420:	1f 93       	push	r17
 422:	cf 93       	push	r28
 424:	df 93       	push	r29
 426:	8c 01       	movw	r16, r24
 428:	c6 2f       	mov	r28, r22
	/*
	 * The user may have put the chip out of Rx mode to perform a
	 * few Tx operations in a row, or they may have left the chip
	 * in Rx which we'll switch back on when this Tx is done.
	 */
	if (nrf24_in_rx) {
 42a:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <nrf24_in_rx>
 42e:	88 23       	and	r24, r24
 430:	31 f0       	breq	.+12     	; 0x43e <nrf24_tx+0x24>
		nrf24_idle_mode(1);
 432:	81 e0       	ldi	r24, 0x01	; 1
 434:	0e 94 71 03 	call	0x6e2	; 0x6e2 <nrf24_idle_mode>

		nrf24_in_rx = 1;
 438:	81 e0       	ldi	r24, 0x01	; 1
 43a:	80 93 44 01 	sts	0x0144, r24	; 0x800144 <nrf24_in_rx>
	}

	/* Tx mode */
	nrf24_write_reg(CONFIG, CONFIG_VAL | (1 << PWR_UP));
 43e:	6e e7       	ldi	r22, 0x7E	; 126
 440:	80 e0       	ldi	r24, 0x00	; 0
 442:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <nrf24_write_reg>
	/* Use pipe 0 for receiving ACK packets */
	nrf24_write_reg(EN_RXADDR, 0x01);
 446:	61 e0       	ldi	r22, 0x01	; 1
 448:	82 e0       	ldi	r24, 0x02	; 2
 44a:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <nrf24_write_reg>
	 * gets retransmitted about 3 times (sometimes 2, sometimes 4)
	 * instead of the chip picking up what we've written.  After that
	 * it picks up whatever the new payload is and again stops accepting
	 * new payloads for another while.
	 */
	nrf24_tx_flush();
 44e:	0e 94 46 04 	call	0x88c	; 0x88c <nrf24_tx_flush>

static inline void nrf24_csn(uint8_t level) {
	if (level)
		CSN_PORT |= CSN_PIN;
	else
		CSN_PORT &= ~CSN_PIN;
 452:	85 b1       	in	r24, 0x05	; 5
 454:	8b 7f       	andi	r24, 0xFB	; 251
 456:	85 b9       	out	0x05, r24	; 5
	 */
	nrf24_tx_flush();

	nrf24_csn(0);

	spi_transfer(W_TX_PAYLOAD);
 458:	80 ea       	ldi	r24, 0xA0	; 160
 45a:	0e 94 24 04 	call	0x848	; 0x848 <spi_transfer>
	while (len --)
 45e:	0a c0       	rjmp	.+20     	; 0x474 <nrf24_tx+0x5a>
		spi_transfer(*buf ++);
 460:	78 01       	movw	r14, r16
 462:	8f ef       	ldi	r24, 0xFF	; 255
 464:	e8 1a       	sub	r14, r24
 466:	f8 0a       	sbc	r15, r24
 468:	f8 01       	movw	r30, r16
 46a:	80 81       	ld	r24, Z
 46c:	0e 94 24 04 	call	0x848	; 0x848 <spi_transfer>
	nrf24_tx_flush();

	nrf24_csn(0);

	spi_transfer(W_TX_PAYLOAD);
	while (len --)
 470:	cd 2f       	mov	r28, r29
		spi_transfer(*buf ++);
 472:	87 01       	movw	r16, r14
	nrf24_tx_flush();

	nrf24_csn(0);

	spi_transfer(W_TX_PAYLOAD);
	while (len --)
 474:	df ef       	ldi	r29, 0xFF	; 255
 476:	dc 0f       	add	r29, r28
 478:	c1 11       	cpse	r28, r1
 47a:	f2 cf       	rjmp	.-28     	; 0x460 <nrf24_tx+0x46>
 */
#include "nRF24L01.h"

static inline void nrf24_csn(uint8_t level) {
	if (level)
		CSN_PORT |= CSN_PIN;
 47c:	85 b1       	in	r24, 0x05	; 5
 47e:	84 60       	ori	r24, 0x04	; 4
 480:	85 b9       	out	0x05, r24	; 5
	else
		while (timer_read() - prev_ce_edge <= F_CPU / 5000);
#else
	/* This should take at least 10us (rising) or 200us (falling) */
	if (level)
		my_delay(10);
 482:	8a e0       	ldi	r24, 0x0A	; 10
 484:	90 e0       	ldi	r25, 0x00	; 0
 486:	0e 94 c2 03 	call	0x784	; 0x784 <delay8>
	else
		my_delay(200);
#endif

	if (level)
		CE_PORT |= CE_PIN;
 48a:	85 b1       	in	r24, 0x05	; 5
 48c:	82 60       	ori	r24, 0x02	; 2
 48e:	85 b9       	out	0x05, r24	; 5
	/*
	 * Set CE high for at least 10us - that's 160 cycles at 16MHz.
	 * But we can also leave it that way until tx_result_wait().
	 */
	nrf24_ce(1);
}
 490:	df 91       	pop	r29
 492:	cf 91       	pop	r28
 494:	1f 91       	pop	r17
 496:	0f 91       	pop	r16
 498:	ff 90       	pop	r15
 49a:	ef 90       	pop	r14
 49c:	08 95       	ret

Disassembly of section .text.nrf24_tx_result_wait:

00000594 <nrf24_tx_result_wait>:

static int nrf24_tx_result_wait(void) {
 594:	0f 93       	push	r16
 596:	1f 93       	push	r17
 598:	cf 93       	push	r28
 59a:	df 93       	push	r29
	uint8_t status;
	uint16_t count = 1000; /* ~100ms timeout */

	status = nrf24_read_status();
 59c:	0e 94 3c 04 	call	0x878	; 0x878 <nrf24_read_status>
 5a0:	c8 2f       	mov	r28, r24
#else
	/* This should take at least 10us (rising) or 200us (falling) */
	if (level)
		my_delay(10);
	else
		my_delay(200);
 5a2:	88 ec       	ldi	r24, 0xC8	; 200
 5a4:	90 e0       	ldi	r25, 0x00	; 0
 5a6:	0e 94 c2 03 	call	0x784	; 0x784 <delay8>
#endif

	if (level)
		CE_PORT |= CE_PIN;
	else
		CE_PORT &= ~CE_PIN;
 5aa:	85 b1       	in	r24, 0x05	; 5
 5ac:	8d 7f       	andi	r24, 0xFD	; 253
 5ae:	85 b9       	out	0x05, r24	; 5
	nrf24_ce(1);
}

static int nrf24_tx_result_wait(void) {
	uint8_t status;
	uint16_t count = 1000; /* ~100ms timeout */
 5b0:	08 ee       	ldi	r16, 0xE8	; 232
 5b2:	13 e0       	ldi	r17, 0x03	; 3
 5b4:	07 c0       	rjmp	.+14     	; 0x5c4 <nrf24_tx_result_wait+0x30>
	/* Reset CE early so that a new Tx or Rx op can start sooner. */
	nrf24_ce(0);

	while ((!(status & (1 << TX_DS)) || (status & (1 << TX_FULL))) &&
			!(status & (1 << MAX_RT)) && --count) {
		delay8((int) (100));
 5b6:	84 e6       	ldi	r24, 0x64	; 100
 5b8:	90 e0       	ldi	r25, 0x00	; 0
 5ba:	0e 94 c2 03 	call	0x784	; 0x784 <delay8>
		status = nrf24_read_status();
 5be:	0e 94 3c 04 	call	0x878	; 0x878 <nrf24_read_status>
 5c2:	c8 2f       	mov	r28, r24
	status = nrf24_read_status();

	/* Reset CE early so that a new Tx or Rx op can start sooner. */
	nrf24_ce(0);

	while ((!(status & (1 << TX_DS)) || (status & (1 << TX_FULL))) &&
 5c4:	dc 2f       	mov	r29, r28
 5c6:	d0 72       	andi	r29, 0x20	; 32
 5c8:	c5 ff       	sbrs	r28, 5
 5ca:	02 c0       	rjmp	.+4      	; 0x5d0 <nrf24_tx_result_wait+0x3c>
 5cc:	c0 ff       	sbrs	r28, 0
 5ce:	05 c0       	rjmp	.+10     	; 0x5da <nrf24_tx_result_wait+0x46>
 5d0:	c4 fd       	sbrc	r28, 4
 5d2:	03 c0       	rjmp	.+6      	; 0x5da <nrf24_tx_result_wait+0x46>
			!(status & (1 << MAX_RT)) && --count) {
 5d4:	01 50       	subi	r16, 0x01	; 1
 5d6:	11 09       	sbc	r17, r1
 5d8:	71 f7       	brne	.-36     	; 0x5b6 <nrf24_tx_result_wait+0x22>
		delay8((int) (100));
		status = nrf24_read_status();
	}

	/* Reset status bits */
	nrf24_write_reg(STATUS, (1 << MAX_RT) | (1 << TX_DS));
 5da:	60 e3       	ldi	r22, 0x30	; 48
 5dc:	87 e0       	ldi	r24, 0x07	; 7
 5de:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <nrf24_write_reg>

	if (nrf24_in_rx) {
 5e2:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <nrf24_in_rx>
 5e6:	88 23       	and	r24, r24
 5e8:	21 f0       	breq	.+8      	; 0x5f2 <nrf24_tx_result_wait+0x5e>
		nrf24_in_rx = 0;
 5ea:	10 92 44 01 	sts	0x0144, r1	; 0x800144 <nrf24_in_rx>

		nrf24_rx_mode();
 5ee:	0e 94 ac 03 	call	0x758	; 0x758 <nrf24_rx_mode>
	}

	return (status & (1 << TX_DS)) ? 0 : -1;
 5f2:	dd 23       	and	r29, r29
 5f4:	19 f0       	breq	.+6      	; 0x5fc <nrf24_tx_result_wait+0x68>
 5f6:	80 e0       	ldi	r24, 0x00	; 0
 5f8:	90 e0       	ldi	r25, 0x00	; 0
 5fa:	02 c0       	rjmp	.+4      	; 0x600 <nrf24_tx_result_wait+0x6c>
 5fc:	8f ef       	ldi	r24, 0xFF	; 255
 5fe:	9f ef       	ldi	r25, 0xFF	; 255
}
 600:	df 91       	pop	r29
 602:	cf 91       	pop	r28
 604:	1f 91       	pop	r17
 606:	0f 91       	pop	r16
 608:	08 95       	ret

Disassembly of section .text.radio_init:

0000049e <radio_init>:
#include "spi.h"
#include "nrf24.h"

#define SEQN

static void radio_init(void) {
 49e:	cf 93       	push	r28
 4a0:	df 93       	push	r29
 4a2:	00 d0       	rcall	.+0      	; 0x4a4 <radio_init+0x6>
 4a4:	1f 92       	push	r1
 4a6:	cd b7       	in	r28, 0x3d	; 61
 4a8:	de b7       	in	r29, 0x3e	; 62
  uint8_t addr[3];

  spi_init();
 4aa:	0e 94 fe 03 	call	0x7fc	; 0x7fc <spi_init>

  if (nrf24_init())
 4ae:	0e 94 8d 02 	call	0x51a	; 0x51a <nrf24_init>
 4b2:	89 2b       	or	r24, r25
 4b4:	61 f5       	brne	.+88     	; 0x50e <__stack+0xf>
    return;

  radio_present = 1;
 4b6:	81 e0       	ldi	r24, 0x01	; 1
 4b8:	80 93 46 01 	sts	0x0146, r24	; 0x800146 <radio_present>
   * of the first packet we receive from the master.
   */
  /*
  Since addresses defined by me, have a first value between 0x20 - 0x40 exclusive
  */
   addr[0] = eeprom_read(0);
 4bc:	80 e0       	ldi	r24, 0x00	; 0
 4be:	90 e0       	ldi	r25, 0x00	; 0
 4c0:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <eeprom_read>
 4c4:	89 83       	std	Y+1, r24	; 0x01
	if(addr[0] > 0x40||addr[0] < 0x20){
 4c6:	80 52       	subi	r24, 0x20	; 32
 4c8:	81 32       	cpi	r24, 0x21	; 33
 4ca:	88 f0       	brcs	.+34     	; 0x4ee <radio_init+0x50>
	   eeprom_write_byte(0,0x30);
 4cc:	60 e3       	ldi	r22, 0x30	; 48
 4ce:	80 e0       	ldi	r24, 0x00	; 0
 4d0:	90 e0       	ldi	r25, 0x00	; 0
 4d2:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <eeprom_write_byte>
	   eeprom_write_byte(1,0x30);
 4d6:	60 e3       	ldi	r22, 0x30	; 48
 4d8:	81 e0       	ldi	r24, 0x01	; 1
 4da:	90 e0       	ldi	r25, 0x00	; 0
 4dc:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <eeprom_write_byte>
	   eeprom_write_byte(2,0x31);
 4e0:	61 e3       	ldi	r22, 0x31	; 49
 4e2:	82 e0       	ldi	r24, 0x02	; 2
 4e4:	90 e0       	ldi	r25, 0x00	; 0
 4e6:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <eeprom_write_byte>
	   addr[0] = 0x30;
 4ea:	80 e3       	ldi	r24, 0x30	; 48
 4ec:	89 83       	std	Y+1, r24	; 0x01
	}
   addr[1] = eeprom_read(1);
 4ee:	81 e0       	ldi	r24, 0x01	; 1
 4f0:	90 e0       	ldi	r25, 0x00	; 0
 4f2:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <eeprom_read>
 4f6:	8a 83       	std	Y+2, r24	; 0x02
   addr[2] = eeprom_read(2);
 4f8:	82 e0       	ldi	r24, 0x02	; 2
 4fa:	90 e0       	ldi	r25, 0x00	; 0
 4fc:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <eeprom_read>
 500:	8b 83       	std	Y+3, r24	; 0x03
  nrf24_set_rx_addr(addr);
 502:	ce 01       	movw	r24, r28
 504:	01 96       	adiw	r24, 0x01	; 1
 506:	0e 94 8d 04 	call	0x91a	; 0x91a <nrf24_set_rx_addr>

  nrf24_rx_mode();
 50a:	0e 94 ac 03 	call	0x758	; 0x758 <nrf24_rx_mode>
}
 50e:	0f 90       	pop	r0
 510:	0f 90       	pop	r0
 512:	0f 90       	pop	r0
 514:	df 91       	pop	r29
 516:	cf 91       	pop	r28
 518:	08 95       	ret

Disassembly of section .text.putch:

0000060a <putch>:
#endif

void putch(char ch) {
 60a:	cf 93       	push	r28
#ifdef RADIO_UART
  if (radio_mode) {
 60c:	90 91 47 01 	lds	r25, 0x0147	; 0x800147 <radio_mode>
 610:	99 23       	and	r25, r25
 612:	71 f1       	breq	.+92     	; 0x670 <putch+0x66>
    static uint8_t pkt_len = 0;
    static uint8_t pkt_buf[32];

    pkt_buf[pkt_len++] = ch;
 614:	e0 91 43 01 	lds	r30, 0x0143	; 0x800143 <pkt_len.1981>
 618:	91 e0       	ldi	r25, 0x01	; 1
 61a:	9e 0f       	add	r25, r30
 61c:	90 93 43 01 	sts	0x0143, r25	; 0x800143 <pkt_len.1981>
 620:	f0 e0       	ldi	r31, 0x00	; 0
 622:	e0 5e       	subi	r30, 0xE0	; 224
 624:	fe 4f       	sbci	r31, 0xFE	; 254
 626:	80 83       	st	Z, r24

    if (ch == STK_OK || pkt_len == pkt_max_len) {
 628:	80 31       	cpi	r24, 0x10	; 16
 62a:	a1 f0       	breq	.+40     	; 0x654 <putch+0x4a>
 62c:	80 91 45 01 	lds	r24, 0x0145	; 0x800145 <pkt_max_len>
 630:	98 13       	cpse	r25, r24
 632:	24 c0       	rjmp	.+72     	; 0x67c <putch+0x72>
 634:	11 c0       	rjmp	.+34     	; 0x658 <putch+0x4e>
#ifdef SEQN
      uint8_t cnt = 128;

      while (--cnt) {
        /* Wait 4ms to allow the remote end to switch to Rx mode */
        my_delay(4000);
 636:	80 ea       	ldi	r24, 0xA0	; 160
 638:	9f e0       	ldi	r25, 0x0F	; 15
 63a:	0e 94 c2 03 	call	0x784	; 0x784 <delay8>

        nrf24_tx(pkt_buf, pkt_len);
 63e:	60 91 43 01 	lds	r22, 0x0143	; 0x800143 <pkt_len.1981>
 642:	80 e2       	ldi	r24, 0x20	; 32
 644:	91 e0       	ldi	r25, 0x01	; 1
 646:	0e 94 0d 02 	call	0x41a	; 0x41a <nrf24_tx>
        if (!nrf24_tx_result_wait())
 64a:	0e 94 ca 02 	call	0x594	; 0x594 <nrf24_tx_result_wait>
 64e:	89 2b       	or	r24, r25
 650:	21 f4       	brne	.+8      	; 0x65a <putch+0x50>
 652:	05 c0       	rjmp	.+10     	; 0x65e <putch+0x54>
 654:	c0 e8       	ldi	r28, 0x80	; 128
 656:	01 c0       	rjmp	.+2      	; 0x65a <putch+0x50>
 658:	c0 e8       	ldi	r28, 0x80	; 128

    if (ch == STK_OK || pkt_len == pkt_max_len) {
#ifdef SEQN
      uint8_t cnt = 128;

      while (--cnt) {
 65a:	c1 50       	subi	r28, 0x01	; 1
 65c:	61 f7       	brne	.-40     	; 0x636 <putch+0x2c>
	 * maybe has given up and is resending the full command which
	 * is ok.
	 */
      }

      pkt_len = 1;
 65e:	81 e0       	ldi	r24, 0x01	; 1
 660:	80 93 43 01 	sts	0x0143, r24	; 0x800143 <pkt_len.1981>
      pkt_buf[0] ++;
 664:	e0 e2       	ldi	r30, 0x20	; 32
 666:	f1 e0       	ldi	r31, 0x01	; 1
 668:	80 81       	ld	r24, Z
 66a:	8f 5f       	subi	r24, 0xFF	; 255
 66c:	80 83       	st	Z, r24
 66e:	06 c0       	rjmp	.+12     	; 0x67c <putch+0x72>

    return;
  }
#endif
#ifndef SOFT_UART
  while (!(UART_SRA & _BV(UDRE0)));
 670:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fc0c0>
 674:	95 ff       	sbrs	r25, 5
 676:	fc cf       	rjmp	.-8      	; 0x670 <putch+0x66>
  UART_UDR = ch;
 678:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fc0c6>
      [uartBit] "I" (UART_TX_BIT)
    :
      "r25"
  );
#endif
}
 67c:	cf 91       	pop	r28
 67e:	08 95       	ret

Disassembly of section .text.getch:

0000035c <getch>:
      break;
    }
#endif

#ifdef RADIO_UART
    if (radio_present && (pkt_len || nrf24_rx_fifo_data())) {
 35c:	80 91 46 01 	lds	r24, 0x0146	; 0x800146 <radio_present>
 360:	88 23       	and	r24, r24
 362:	e1 f3       	breq	.-8      	; 0x35c <getch>
 364:	80 91 42 01 	lds	r24, 0x0142	; 0x800142 <pkt_len.1994>
 368:	81 11       	cpse	r24, r1
 36a:	04 c0       	rjmp	.+8      	; 0x374 <getch+0x18>
 36c:	0e 94 74 04 	call	0x8e8	; 0x8e8 <nrf24_rx_fifo_data>
 370:	88 23       	and	r24, r24
 372:	a1 f3       	breq	.-24     	; 0x35c <getch>
}
#endif

// Watchdog functions. These are only safe with interrupts turned off.
void watchdogReset() {
  __asm__ __volatile__ (
 374:	a8 95       	wdr

#ifdef RADIO_UART
    if (radio_present && (pkt_len || nrf24_rx_fifo_data())) {
      watchdogReset();

      if (!pkt_len) {
 376:	80 91 42 01 	lds	r24, 0x0142	; 0x800142 <pkt_len.1994>
 37a:	81 11       	cpse	r24, r1
 37c:	3e c0       	rjmp	.+124    	; 0x3fa <getch+0x9e>
        static uint8_t seqn = 0xff;
#define START 1
#else
#define START 0
#endif
        nrf24_rx_read(pkt_buf, &pkt_len);
 37e:	62 e4       	ldi	r22, 0x42	; 66
 380:	71 e0       	ldi	r23, 0x01	; 1
 382:	80 e0       	ldi	r24, 0x00	; 0
 384:	91 e0       	ldi	r25, 0x01	; 1
 386:	0e 94 40 03 	call	0x680	; 0x680 <nrf24_rx_read>
        pkt_start = START;
 38a:	81 e0       	ldi	r24, 0x01	; 1
 38c:	80 93 41 01 	sts	0x0141, r24	; 0x800141 <pkt_start.1995>

        if (!radio_mode && pkt_len >= 4) {
 390:	80 91 47 01 	lds	r24, 0x0147	; 0x800147 <radio_mode>
 394:	81 11       	cpse	r24, r1
 396:	1a c0       	rjmp	.+52     	; 0x3cc <getch+0x70>
 398:	90 91 42 01 	lds	r25, 0x0142	; 0x800142 <pkt_len.1994>
 39c:	94 30       	cpi	r25, 0x04	; 4
 39e:	b0 f0       	brcs	.+44     	; 0x3cc <getch+0x70>
          /*
           * If this is the first packet we receive, the first three bytes
           * should contain the sender's address.
           */
          nrf24_set_tx_addr(pkt_buf);
 3a0:	80 e0       	ldi	r24, 0x00	; 0
 3a2:	91 e0       	ldi	r25, 0x01	; 1
 3a4:	0e 94 e2 03 	call	0x7c4	; 0x7c4 <nrf24_set_tx_addr>
          pkt_max_len = pkt_buf[3];
 3a8:	80 91 03 01 	lds	r24, 0x0103	; 0x800103 <__data_end+0x3>
 3ac:	80 93 45 01 	sts	0x0145, r24	; 0x800145 <pkt_max_len>
          pkt_len -= 4;
 3b0:	80 91 42 01 	lds	r24, 0x0142	; 0x800142 <pkt_len.1994>
 3b4:	84 50       	subi	r24, 0x04	; 4
 3b6:	80 93 42 01 	sts	0x0142, r24	; 0x800142 <pkt_len.1994>
          pkt_start += 4;
 3ba:	80 91 41 01 	lds	r24, 0x0141	; 0x800141 <pkt_start.1995>
 3be:	8c 5f       	subi	r24, 0xFC	; 252
 3c0:	80 93 41 01 	sts	0x0141, r24	; 0x800141 <pkt_start.1995>

          radio_mode = 1;
 3c4:	81 e0       	ldi	r24, 0x01	; 1
 3c6:	80 93 47 01 	sts	0x0147, r24	; 0x800147 <radio_mode>
 3ca:	04 c0       	rjmp	.+8      	; 0x3d4 <getch+0x78>
        } else if (!radio_mode)
 3cc:	81 11       	cpse	r24, r1
 3ce:	02 c0       	rjmp	.+4      	; 0x3d4 <getch+0x78>
          pkt_len = 0;
 3d0:	10 92 42 01 	sts	0x0142, r1	; 0x800142 <pkt_len.1994>

        if (!pkt_len)
 3d4:	80 91 42 01 	lds	r24, 0x0142	; 0x800142 <pkt_len.1994>
 3d8:	88 23       	and	r24, r24
 3da:	09 f4       	brne	.+2      	; 0x3de <getch+0x82>
 3dc:	bf cf       	rjmp	.-130    	; 0x35c <getch>
          continue;

#ifdef SEQN
        if (pkt_buf[0] == seqn) {
 3de:	90 91 00 01 	lds	r25, 0x0100	; 0x800100 <__data_end>
 3e2:	20 91 40 01 	lds	r18, 0x0140	; 0x800140 <seqn.1997>
 3e6:	92 13       	cpse	r25, r18
 3e8:	03 c0       	rjmp	.+6      	; 0x3f0 <getch+0x94>
          pkt_len = 0;
 3ea:	10 92 42 01 	sts	0x0142, r1	; 0x800142 <pkt_len.1994>
          continue;
 3ee:	b6 cf       	rjmp	.-148    	; 0x35c <getch>
        }

        seqn = pkt_buf[0];
 3f0:	90 93 40 01 	sts	0x0140, r25	; 0x800140 <seqn.1997>
        pkt_len--;
 3f4:	81 50       	subi	r24, 0x01	; 1
 3f6:	80 93 42 01 	sts	0x0142, r24	; 0x800142 <pkt_len.1994>
#endif
      }

      ch = pkt_buf[pkt_start ++];
 3fa:	e0 91 41 01 	lds	r30, 0x0141	; 0x800141 <pkt_start.1995>
 3fe:	81 e0       	ldi	r24, 0x01	; 1
 400:	8e 0f       	add	r24, r30
 402:	80 93 41 01 	sts	0x0141, r24	; 0x800141 <pkt_start.1995>
 406:	f0 e0       	ldi	r31, 0x00	; 0
 408:	e0 50       	subi	r30, 0x00	; 0
 40a:	ff 4f       	sbci	r31, 0xFF	; 255
 40c:	80 81       	ld	r24, Z
      pkt_len --;
 40e:	90 91 42 01 	lds	r25, 0x0142	; 0x800142 <pkt_len.1994>
 412:	91 50       	subi	r25, 0x01	; 1
 414:	90 93 42 01 	sts	0x0142, r25	; 0x800142 <pkt_len.1994>
  LED_PIN |= _BV(LED);
#endif
#endif

  return ch;
}
 418:	08 95       	ret

Disassembly of section .text.watchdogConfig:

00000904 <watchdogConfig>:
    "wdr\n"
  );
}

void watchdogConfig(uint8_t x) {
  WDTCSR = _BV(WDCE) | _BV(WDE);
 904:	e0 e6       	ldi	r30, 0x60	; 96
 906:	f0 e0       	ldi	r31, 0x00	; 0
 908:	98 e1       	ldi	r25, 0x18	; 24
 90a:	90 83       	st	Z, r25
  WDTCSR = x;
 90c:	80 83       	st	Z, r24
 90e:	08 95       	ret

Disassembly of section .text.wait_timeout:

000008f6 <wait_timeout>:
  verifySpace();
}

void wait_timeout(void) {
#ifdef RADIO_UART
  nrf24_idle_mode(0);		      // power the radio off
 8f6:	80 e0       	ldi	r24, 0x00	; 0
 8f8:	0e 94 71 03 	call	0x6e2	; 0x6e2 <nrf24_idle_mode>
#endif
  watchdogConfig(WATCHDOG_16MS);      // shorten WD timeout
 8fc:	88 e0       	ldi	r24, 0x08	; 8
 8fe:	0e 94 82 04 	call	0x904	; 0x904 <watchdogConfig>
 902:	ff cf       	rjmp	.-2      	; 0x902 <wait_timeout+0xc>

Disassembly of section .text.verifySpace:

000008a0 <verifySpace>:
    ;				      //  a reset and app start.
}

void verifySpace(void) {
  char ch;
  ch = getch();
 8a0:	0e 94 ae 01 	call	0x35c	; 0x35c <_etext>
  if (ch!= CRC_EOP)
 8a4:	80 32       	cpi	r24, 0x20	; 32
 8a6:	11 f0       	breq	.+4      	; 0x8ac <verifySpace+0xc>
    wait_timeout();
 8a8:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <wait_timeout>
  putch(STK_INSYNC);
 8ac:	84 e1       	ldi	r24, 0x14	; 20
 8ae:	0e 94 05 03 	call	0x60a	; 0x60a <putch>
 8b2:	08 95       	ret

Disassembly of section .text.appStart:

000008d8 <appStart>:
void watchdogConfig(uint8_t x) {
  WDTCSR = _BV(WDCE) | _BV(WDE);
  WDTCSR = x;
}

void appStart(uint8_t rstFlags) {
 8d8:	c8 2f       	mov	r28, r24
#ifdef FORCE_WATCHDOG
  watchdogConfig(WATCHDOG_4S);
#else
  watchdogConfig(WATCHDOG_OFF);
 8da:	80 e0       	ldi	r24, 0x00	; 0
 8dc:	0e 94 82 04 	call	0x904	; 0x904 <watchdogConfig>
#endif

  // save the reset flags in the designated register
  //  This can be saved in a main program by putting code in .init0 (which
  //  executes before normal c init code) to save R2 to a global variable.
  __asm__ __volatile__ ("mov r2, %0\n" :: "r" (rstFlags));
 8e0:	2c 2e       	mov	r2, r28

  __asm__ __volatile__ (
 8e2:	ee 27       	eor	r30, r30
 8e4:	ff 27       	eor	r31, r31
 8e6:	09 94       	ijmp

Disassembly of section .text.avrlibc:

000007e0 <eeprom_write_byte>:
 7e0:	26 2f       	mov	r18, r22

000007e2 <eeprom_write_r18>:
 7e2:	f9 99       	sbic	0x1f, 1	; 31
 7e4:	fe cf       	rjmp	.-4      	; 0x7e2 <eeprom_write_r18>
 7e6:	1f ba       	out	0x1f, r1	; 31
 7e8:	92 bd       	out	0x22, r25	; 34
 7ea:	81 bd       	out	0x21, r24	; 33
 7ec:	20 bd       	out	0x20, r18	; 32
 7ee:	0f b6       	in	r0, 0x3f	; 63
 7f0:	f8 94       	cli
 7f2:	fa 9a       	sbi	0x1f, 2	; 31
 7f4:	f9 9a       	sbi	0x1f, 1	; 31
 7f6:	0f be       	out	0x3f, r0	; 63
 7f8:	01 96       	adiw	r24, 0x01	; 1
 7fa:	08 95       	ret
